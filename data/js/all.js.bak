// js/api.js
// Fonction pour la mise √† jour de la courbe
function updateTemperatureCurve(newTemperatureData) {
    if (typeof window.temperatureData !== 'undefined' && typeof window.chart !== 'undefined') {
        window.temperatureData = newTemperatureData;
        window.chart.data.datasets[0].data = [...window.temperatureData];
        window.chart.update();
        
        if (typeof window.updateTempGrid === 'function') window.updateTempGrid();
        if (typeof window.updateStatus === 'function') window.updateStatus();
        
        return true;
    }
    return false;
}

// Fonction retourne les donn√©es sans essayer de mettre √† jour l'interface
async function fetchLocalData() {
    const lat = document.getElementById('latInput').value;
    const lon = document.getElementById('lonInput').value;

    const today = new Date();
    const date = today.toISOString().split('T')[0];
    const thisYear = new Date().getFullYear();

    if (!lat || !lon) {
        throw new Error("Latitude et longitude manquantes dans les param√®tres");
    }
 if (window.debugMode) console.log(`[SEASON] Appel API m√©t√©o pour latitude=${lat}, longitude=${lon}, ann√©es=${years.join(',')}`);

  if (window.debugMode)    console.log(`R√©cup√©ration donn√©es m√©t√©o pour ${lat}, ${lon} √† la date ${date}`);

    const years = [thisYear - 4, thisYear - 3, thisYear - 2, thisYear - 1];
    const tempData = [];
    const humData = [];

    try {
        for (let year of years) {
            console.log(`R√©cup√©ration ann√©e ${year}...`);
            
            try {
                const data = await fetchData(year, date, lat, lon);

                if (data.hourly && data.hourly.temperature_2m && data.hourly.temperature_2m.length === 24) {
                    tempData.push(data.hourly.temperature_2m);
                    if (data.hourly.relative_humidity_2m && data.hourly.relative_humidity_2m.length === 24) {
                        humData.push(data.hourly.relative_humidity_2m);
                    }
                } else {
                    console.warn(`Donn√©es incompl√®tes pour ${year}`);
                }
            } catch (yearError) {
                console.warn(`Erreur pour l'ann√©e ${year}:`, yearError.message);
                // Continuer avec les autres ann√©es
                continue;
            }
        }

        if (tempData.length === 0) {
            throw new Error("Aucune donn√©e m√©t√©o disponible pour cette p√©riode et ces coordonn√©es");
        }

        const avgTemps = averageArrays(tempData);
        const avgHumidity = humData.length > 0 ? averageArrays(humData) : null;

        if (window.debugMode) console.log(`[SEASON] Temp√©ratures moyennes calcul√©es sur ${tempData.length} ann√©es:`, avgTemps);
/*
        // Conversion des temp√©ratures pour le terrarium
        const processedTemps = avgTemps.map(temp => {
            // Utiliser globalMinTempSet et globalMaxTempSet pour la s√©curit√© du terrarium
            return Math.max(globalMinTempSet, Math.min(globalMaxTempSet, Math.round(temp * 10) / 10));
        }); 
*/
        // Conversion des temp√©ratures pour le terrarium sans limitation arrondi √† un chiffre apr√®s la virgule
        const processedTemps = avgTemps.map(temp => {
            // Retourner simplement la temp√©rature arrondie
            return Math.round(temp * 10) / 10;
        });
        
        if (window.debugMode) console.log(`[SEASON] Temp√©ratures ajust√©es (limit√©es entre ${globalMinTempSet} et ${globalMaxTempSet}):`, processedTemps);


        return {
            temperatures: processedTemps,
            humidity: avgHumidity,
            rawTemperatures: avgTemps,
            success: true,
            dataPoints: tempData.length
        };

    } catch (error) {
        console.error("Erreur r√©cup√©ration donn√©es m√©t√©o:", error);
        throw error;
    }
}

// Fonction pour r√©cup√©rer les donn√©es d'une ann√©e
async function fetchData(year, date, lat, lon) {
    const [y, m, d] = date.split("-");
    const dateStr = `${year}-${m.padStart(2, '0')}-${d.padStart(2, '0')}`;
    const url = `https://archive-api.open-meteo.com/v1/archive?latitude=${lat}&longitude=${lon}&start_date=${dateStr}&end_date=${dateStr}&hourly=temperature_2m,relative_humidity_2m&timezone=Europe%2FParis`;

    console.log(`Requ√™te API: ${url}`);

    try {
        const res = await fetch(url);
        if (!res.ok) {
            throw new Error(`HTTP ${res.status}: ${res.statusText}`);
        }
        
        const data = await res.json();
        
        // Validation des donn√©es re√ßues
        if (!data.hourly) {
            throw new Error(`Pas de donn√©es horaires pour ${year}`);
        }
        
        if (!data.hourly.temperature_2m || data.hourly.temperature_2m.length !== 24) {
            throw new Error(`Donn√©es de temp√©rature incompl√®tes pour ${year} (${data.hourly.temperature_2m ? data.hourly.temperature_2m.length : 0} points au lieu de 24)`);
        }
        
        return data;
    } catch (error) {
        console.error(`Erreur API m√©t√©o pour ${year}:`, error);
        throw error;
    }
}

// Fonction pour calculer la moyenne de plusieurs tableaux
function averageArrays(arrays) {
    if (!arrays || arrays.length === 0) {
        throw new Error("Aucun tableau fourni pour le calcul de moyenne");
    }
    
    const n = arrays.length;
    const result = [];
    
    for (let i = 0; i < 24; i++) {
        let sum = 0;
        let validValues = 0;
        
        for (let arr of arrays) {
            if (arr[i] !== null && arr[i] !== undefined && !isNaN(arr[i])) {
                sum += arr[i];
                validValues++;
            }
        }
        
        if (validValues > 0) {
            result.push(sum / validValues);
        } else {
            // Valeur par d√©faut si aucune donn√©e valide
            result.push(i >= 6 && i <= 18 ? 25 : 22); // Jour: 25¬∞C, Nuit: 22¬∞C
        }
    }
    
    return result;
}

// Validation des coordonn√©es
function validateAndGetCoordinates() {
    const lat = document.getElementById('latInput').value;
    const lon = document.getElementById('lonInput').value;
    
    if (!lat || !lon) {
        // Tentative de g√©olocalisation automatique
        return new Promise((resolve, reject) => {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        const detectedLat = position.coords.latitude.toFixed(4);
                        const detectedLon = position.coords.longitude.toFixed(4);
                        
                        document.getElementById('latInput').value = detectedLat;
                        document.getElementById('lonInput').value = detectedLon;
                        
                        resolve({ lat: detectedLat, lon: detectedLon });
                    },
                    (error) => reject(new Error("Coordonn√©es manquantes et g√©olocalisation √©chou√©e"))
                );
            } else {
                reject(new Error("Coordonn√©es manquantes et g√©olocalisation non support√©e"));
            }
        });
    }
    
    return Promise.resolve({ lat, lon });
}
// js/map.js
let map = null;
let currentMarker = null;
let mapVisible = false;

// Initialisation de la carte
function initMap() {
    if (map) {
        return; // Carte d√©j√† initialis√©e
    }
    
    // Position par d√©faut (Paris)
    const defaultLat = 48.8566;
    const defaultLon = 2.3522;
    
    // R√©cup√©rer les coordonn√©es actuelles ou utiliser les valeurs par d√©faut
    const currentLat = parseFloat(document.getElementById('latInput').value) || defaultLat;
    const currentLon = parseFloat(document.getElementById('lonInput').value) || defaultLon;
    
    // Cr√©er la carte
    map = L.map('map').setView([currentLat, currentLon], 10);
    
    // Ajouter les tuiles OpenStreetMap (gratuit)
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '¬© OpenStreetMap contributors',
        maxZoom: 18
    }).addTo(map);
    
    // Ajouter un marqueur √† la position actuelle
    if (currentLat && currentLon) {
        addMarker(currentLat, currentLon);
    }
    
    // Gestionnaire de clic sur la carte
    map.on('click', function(e) {
        const lat = e.latlng.lat;
        const lon = e.latlng.lng;
        
        // Mettre √† jour les champs de coordonn√©es
        updateCoordinates(lat, lon);
        
        // D√©placer le marqueur
        addMarker(lat, lon);
        
        console.log(`üìç Nouvelle position s√©lectionn√©e: ${lat.toFixed(4)}, ${lon.toFixed(4)}`);
    });
    
    console.log('üó∫Ô∏è Carte initialis√©e avec succ√®s');
}

// Ajouter ou d√©placer le marqueur
function addMarker(lat, lon) {
    // Supprimer le marqueur existant
    if (currentMarker) {
        map.removeLayer(currentMarker);
    }
    
    // Cr√©er un nouveau marqueur
    currentMarker = L.marker([lat, lon], {
        draggable: true
    }).addTo(map);
    
    // Popup avec les coordonn√©es
    currentMarker.bindPopup(`
        <b>üìç Position s√©lectionn√©e</b><br>
        Latitude: ${lat.toFixed(4)}<br>
        Longitude: ${lon.toFixed(4)}
    `).openPopup();
    
    // Gestionnaire de drag du marqueur
    currentMarker.on('dragend', function(e) {
        const newPos = e.target.getLatLng();
        updateCoordinates(newPos.lat, newPos.lng);
        
        // Mettre √† jour le popup
        currentMarker.bindPopup(`
            <b>üìç Position s√©lectionn√©e</b><br>
            Latitude: ${newPos.lat.toFixed(4)}<br>
            Longitude: ${newPos.lng.toFixed(4)}
        `).openPopup();
        
        console.log(`üîÑ Marqueur d√©plac√©: ${newPos.lat.toFixed(4)}, ${newPos.lng.toFixed(4)}`);
    });
}

// Mettre √† jour les champs de coordonn√©es
function updateCoordinates(lat, lon) {
    document.getElementById('latInput').value = lat.toFixed(4);
    document.getElementById('lonInput').value = lon.toFixed(4);
    
    // D√©clencher l'√©v√©nement change pour les autres fonctions
    document.getElementById('latInput').dispatchEvent(new Event('change'));
    document.getElementById('lonInput').dispatchEvent(new Event('change'));
}

// Basculer l'affichage de la carte
function toggleMap() {
    const mapContainer = document.getElementById('mapContainer');
    const toggleBtn = document.getElementById('mapToggleBtn');
    
    if (!mapVisible) {
        // Afficher la carte
        mapContainer.style.display = 'block';
        toggleBtn.innerHTML = 'üó∫Ô∏è Fermer la Carte';
        mapVisible = true;
        
        // Initialiser la carte si n√©cessaire
        if (!map) {
            setTimeout(() => {
                initMap();
                // Redimensionner la carte apr√®s affichage
                map.invalidateSize();
            }, 100);
        } else {
            // Redimensionner la carte existante
            setTimeout(() => {
                map.invalidateSize();
            }, 100);
        }
        
    } else {
        // Masquer la carte
        mapContainer.style.display = 'none';
        toggleBtn.innerHTML = 'üó∫Ô∏è Ouvrir la Carte';
        mapVisible = false;
    }
}

// Centrer la carte sur une position
function centerMapOn(lat, lon, zoom = 12) {
    if (map) {
        map.setView([lat, lon], zoom);
        addMarker(lat, lon);
    }
}

// G√©olocalisation am√©lior√©e
function getCurrentLocation() {
    if (!navigator.geolocation) {
        alert('‚ùå La g√©olocalisation n\'est pas support√©e par votre navigateur');
        return;
    }
    
    // Afficher un indicateur de chargement
    const btn = event.target;
    const originalText = btn.innerHTML;
    btn.innerHTML = 'üîÑ Localisation...';
    btn.disabled = true;
    
    navigator.geolocation.getCurrentPosition(
        (position) => {
            const lat = position.coords.latitude;
            const lon = position.coords.longitude;
            const accuracy = position.coords.accuracy;
            
            // Mettre √† jour les coordonn√©es
            updateCoordinates(lat, lon);
            
            // Centrer la carte si elle est visible
            if (mapVisible && map) {
                centerMapOn(lat, lon, 14);
            }
            
            // Restaurer le bouton
            btn.innerHTML = originalText;
            btn.disabled = false;
            
            console.log(`üìç Position d√©tect√©e: ${lat.toFixed(4)}, ${lon.toFixed(4)} (pr√©cision: ${accuracy.toFixed(0)}m)`);
            
            // Afficher une confirmation
            alert(`‚úÖ Position d√©tect√©e avec succ√®s !\nLatitude: ${lat.toFixed(4)}\nLongitude: ${lon.toFixed(4)}\nPr√©cision: ${accuracy.toFixed(0)}m`);
        },
        (error) => {
            // Restaurer le bouton
            btn.innerHTML = originalText;
            btn.disabled = false;
            
            let errorMessage = '‚ùå Erreur de g√©olocalisation: ';
            switch (error.code) {
                case error.PERMISSION_DENIED:
                    errorMessage += 'Permission refus√©e par l\'utilisateur';
                    break;
                case error.POSITION_UNAVAILABLE:
                    errorMessage += 'Position non disponible';
                    break;
                case error.TIMEOUT:
                    errorMessage += 'D√©lai d\'attente d√©pass√©';
                    break;
                default:
                    errorMessage += 'Erreur inconnue';
                    break;
            }
            
            console.warn(errorMessage);
            alert(errorMessage);
        },
        {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 300000 // 5 minutes
        }
    );
}

// Recherche d'adresse (optionnel - n√©cessite une API de g√©ocodage)
function searchLocation() {
    const address = prompt('üîç Entrez une adresse ou nom de lieu:');
    if (!address) return;
    
    // Utilisation de l'API Nominatim (gratuite) pour le g√©ocodage
    const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}&limit=1`;
    
    fetch(url)
        .then(response => response.json())
        .then(data => {
            if (data && data.length > 0) {
                const result = data[0];
                const lat = parseFloat(result.lat);
                const lon = parseFloat(result.lon);
                
                updateCoordinates(lat, lon);
                
                if (mapVisible && map) {
                    centerMapOn(lat, lon, 12);
                }
                
                alert(`‚úÖ Lieu trouv√©: ${result.display_name}\nLatitude: ${lat.toFixed(4)}\nLongitude: ${lon.toFixed(4)}`);
            } else {
                alert('‚ùå Lieu non trouv√©. Essayez avec une adresse plus pr√©cise.');
            }
        })
        .catch(error => {
            console.error('Erreur de g√©ocodage:', error);
            alert('‚ùå Erreur lors de la recherche d\'adresse');
        });
}


//configuration.js
 // coube ajustable
let chart;
let temperatureData = Array(24).fill(0).map((_, i) => 22 + Math.sin(i / 24 * Math.PI * 2) * 6); // Courbe sinuso√Ødale par d√©faut
let extendedTemperatureData = [temperatureData[temperatureData.length - 1], ...temperatureData, temperatureData[0]];
let isDragging = false;
let currentHour = new Date().getHours();
let currentMin = new Date().getMinutes();
let refreshing = false;

function updateCameraVisibility() {
	const show = document.getElementById("showCamera").checked;
	const container = document.getElementById("cameraContainer");
	const img = document.getElementById("camStream");

	container.style.display = show ? "block" : "none";
	cameraEnabled = show;

	fetch("/setCamera?enabled=" + (show ? 1 : 0))
		.catch(err => console.error("Erreur setCamera:", err));

	if (show && !refreshing) {
		startImageLoop(img);
	}
}

function startImageLoop(img, interval = 1000) {
	refreshing = true;

	const loadNextImage = () => {
		if (!cameraEnabled) {
			refreshing = false;
			return;
		}

		const ts = Date.now();
		const newImg = new Image();

		newImg.onload = () => {
			// Remplacer l'image visible seulement apr√®s chargement
			img.src = newImg.src;
			setTimeout(loadNextImage, interval);
		};

		newImg.onerror = () => {
			console.warn("Erreur chargement image");
			setTimeout(loadNextImage, interval * 2);
		};

		newImg.src = `/capture?ts=${ts}`;
	};

	loadNextImage();
}

function setResolution() {
    var quality = document.getElementById("cameraResolution").value;
    fetch('/set-resolution-cam', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: 'quality=' + encodeURIComponent(quality)
    })
    .then(response => response.text())
    .then(data => {
        alert("R√©solution mise √† jour : " + data);
    })
    .catch(error => {
        console.error('Erreur:', error);
    });
}
// Fonction pour convertir RGB en hexad√©cimal
function rgbToHex(r, g, b) {
	return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
}

function updateVisibility() {
    // PWM settings
    const pwmChecked = document.getElementById("usePWM").checked;
    const pwmDiv = document.getElementById("pwmSettings");
    const hysteresisDiv = document.getElementById("hysteresisSettings");

    if (pwmDiv) pwmDiv.style.display = pwmChecked ? "block" : "none";
    if (hysteresisDiv) hysteresisDiv.style.display = pwmChecked ? "none" : "block";

    // Weather settings
    const weatherChecked = document.getElementById("weatherMode").checked;
    const weatherDiv = document.getElementById("weatherSettings");
    const copieButton = document.getElementById("copieSettings");

    if (weatherDiv) weatherDiv.style.display = weatherChecked ? "block" : "none";
    if (copieButton) copieButton.style.display = weatherChecked ? "inline-block" : "none";

    // Temperature limit settings
    const limitTempChecked = document.getElementById("useLimitTemp").checked;
    const limitTempDiv = document.getElementById("limitTempSettings");

    if (limitTempDiv) limitTempDiv.style.display = limitTempChecked ? "block" : "none";

    // Seasonal visibility - Appeler la fonction d√©di√©e
    if (typeof updateSeasonalVisibility === 'function') {
        updateSeasonalVisibility();
    }
}

// Dans configuration.js - Modifier loadCurrentConfigToUI()
async function loadCurrentConfigToUI() {
    try {
        const res = await fetch('/getCurrentConfig');
        if (!res.ok) throw new Error("Erreur lors de la lecture de la configuration");

        const config = await res.json();

        // Remplissage des champs standards
        document.getElementById("hysteresisSet").value = config.hysteresis;
        document.getElementById("KpSet").value = config.Kp;
        document.getElementById("KiSet").value = config.Ki;
        document.getElementById("KdSet").value = config.Kd;
        document.getElementById("usePWM").checked = !!config.usePWM;
        document.getElementById("latInput").value = config.latitude;
        document.getElementById("lonInput").value = config.longitude;
        document.getElementById("weatherMode").checked = !!config.weatherModeEnabled;
        document.getElementById("showCamera").checked = !!config.cameraEnabled;
        document.getElementById("cameraResolution").value = config.cameraResolution;
        document.getElementById("useLimitTemp").checked = !!config.useLimitTemp;
        document.getElementById("maxTempSet").value = config.globalMaxTempSet;
        document.getElementById("minTempSet").value = config.globalMinTempSet;

        // Nouveau: Charger l'√©tat du mode saisonnier
        const seasonalModeElement = document.getElementById("seasonalMode");
        if (seasonalModeElement) {
            seasonalModeElement.checked = !!config.seasonalModeEnabled;
        }

        // üîß Configuration LED - SANS appeler saveConfigurationled()
        const ledToggle = document.getElementById("led-toggle");
        const brightnessSlider = document.getElementById("brightness-slider");
        const brightnessValue = document.getElementById("brightness-value");

        if (ledToggle && brightnessSlider && brightnessValue) {
            ledToggle.checked = !!config.ledState;
            brightnessSlider.value = config.ledBrightness;
            brightnessValue.textContent = config.ledBrightness;

            // Attendre que Spectrum soit pr√™t avant de configurer la couleur
            if (typeof config.ledRed === "number" && 
                typeof config.ledGreen === "number" && 
                typeof config.ledBlue === "number") {
                
                const hexColor = rgbToHex(config.ledRed, config.ledGreen, config.ledBlue);
                
                // Attendre l'initialisation de Spectrum
                setTimeout(() => {
                    try {
                        const colorPicker = $("#color-picker");
                        if (colorPicker.length && typeof colorPicker.spectrum === 'function') {
                            colorPicker.spectrum("set", hexColor);
                            updateLedDot();
                        }
                    } catch (error) {
                        console.warn("‚ö†Ô∏è Impossible de configurer la couleur LED:", error.message);
                    }
                }, 1000); // D√©lai pour laisser Spectrum s'initialiser
            }
        } else {
            console.warn("‚ö†Ô∏è √âl√©ment LED manquant dans le DOM");
        }

        // üìà Charger la courbe de temp√©rature
        if (Array.isArray(config.tempCurve)) {
            temperatureData = config.tempCurve;
            updateChartAndGrid();
        }

        // Mettre √† jour la visibilit√© des sections
        updateVisibility();

        // Mettre √† jour la taille de l'image de la cam√©ra
        if (typeof setStreamDimensions === 'function') {
            setStreamDimensions(config.cameraResolution);
        }

        console.log("‚úÖ Configuration recharg√©e depuis l'ESP");
    } catch (e) {
        console.error("‚ùå Erreur de lecture config :", e);
    }
}

// Save all settings
function applyAllSettings() {
    console.log("üîÑ D√©but de la sauvegarde de la configuration...");

    const get = (id) => document.getElementById(id);

    const fields = [
        "hysteresisSet", "KpSet", "KiSet", "KdSet",
        "usePWM", "latInput", "lonInput",
        "weatherMode", "seasonalMode", "showCamera", "cameraResolution", "useLimitTemp",
        "maxTempSet", "minTempSet",
        "led-toggle", "brightness-slider", "color-picker"
    ];

    // üîç V√©rification des √©l√©ments requis
    for (const id of fields) {
        if (!get(id)) {
            alert(`‚ùå √âl√©ment ${id} introuvable`);
            console.error(`‚ùå √âl√©ment ${id} introuvable`);
            return;
        }
    }

    // ‚úÖ Conversion couleur LED en RGB
    let red = 255, green = 255, blue = 255;
    let color = "#ffffff";
    try {
        color = $("#color-picker").spectrum("get").toHexString();
        red = parseInt(color.substr(1, 2), 16);
        green = parseInt(color.substr(3, 2), 16);
        blue = parseInt(color.substr(5, 2), 16);
    } catch (e) {
        console.warn("‚ö†Ô∏è Erreur de r√©cup√©ration couleur, valeurs par d√©faut utilis√©es.");
    }

    // üì¶ Cr√©ation de l'objet de configuration global
    const payload = {
        hysteresis: parseFloat(get("hysteresisSet").value),
        Kp: parseFloat(get("KpSet").value),
        Ki: parseFloat(get("KiSet").value),
        Kd: parseFloat(get("KdSet").value),
        usePWM: get("usePWM").checked ? 1 : 0,
        globalMinTempSet: parseFloat(get("minTempSet").value),
        globalMaxTempSet: parseFloat(get("maxTempSet").value),
        latitude: parseFloat(get("latInput").value),
        longitude: parseFloat(get("lonInput").value),
        weatherModeEnabled: get("weatherMode").checked ? 1 : 0,
        seasonalModeEnabled: get("seasonalMode").checked ? 1 : 0, // Nouveau
        cameraEnabled: get("showCamera").checked ? 1 : 0,
		cameraResolution: get("cameraResolution").value,
        useLimitTemp: get("useLimitTemp").checked ? 1 : 0,
        tempCurve: [...temperatureData],  
        ledState: get("led-toggle").checked,
        ledBrightness: parseInt(get("brightness-slider").value),
        ledRed: red,
        ledGreen: green,
        ledBlue: blue
    };

    console.log("üìä Configuration compl√®te √† envoyer :");
    console.log(payload);

    // Envoi vers serveur
    fetch("/applyAllSettings", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
    })
    .then(res => {
        if (!res.ok) throw new Error("√âchec serveur : " + res.status);
        return res.text();
    })
    .then(txt => {
        console.log("‚úÖ R√©ponse du serveur :", txt);
        const btn = get("applyBtn");
        btn.innerHTML = '<i class="fas fa-check mr-2"></i>Sauvegard√© !';
        btn.style.background = '#4ade80';
        setTimeout(() => {
            btn.innerHTML = '<i class="fas fa-download mr-2"></i>Sauvegarder Configuration';
            btn.style.background = '';
        }, 2000);

        setTimeout(() => {
            if (typeof loadCurrentConfigToUI === "function") {
                loadCurrentConfigToUI();
            }
        }, 1000);
    })
    .catch(err => {
        console.error("‚ùå Erreur lors de l'application :", err);
        alert("Erreur : " + err.message);
    });
}

// Load historical data
function loadHistory() {
	fetch("/history")
		.then(res => res.json())
		.then(data => {
			const timeLabels = data.map(entry => new Date(entry.t * 1000).toLocaleTimeString());
			const temperatures = data.map(entry => entry.temp);
			const humidities = data.map(entry => entry.hum);

			tempChart.data.labels = timeLabels;
			tempChart.data.datasets[0].data = temperatures;
			
			// Calculate moving averages for historical data
			const tempMovingAvg = calculateMovingAverage(temperatures, Math.min(temperatures.length, 1440));
			tempChart.data.datasets[1].data = tempMovingAvg;
			tempChart.update();

			humidityChart.data.labels = timeLabels;
			humidityChart.data.datasets[0].data = humidities;
			
			const humMovingAvg = calculateMovingAverage(humidities, Math.min(humidities.length, 1440));
			humidityChart.data.datasets[1].data = humMovingAvg;
			humidityChart.update();
		})
		.catch(err => console.error("Erreur chargement historique:", err));
}

// Propagation des valeurs extr√®mes de la courbe
function updateTemperatureFromExtendedIndex(index, temp) {
    // Propagation depuis extendedTemperatureData vers temperatureData
    if (index === 0) {
        // 23h
        updateTemperature(23, temp);
    } else if (index === 25) {
        // 0h
        updateTemperature(0, temp);
    } else if (index >= 1 && index <= 24) {
        // index 1 ‚Üí 0h, index 2 ‚Üí 1h, ..., index 24 ‚Üí 23h
        updateTemperature(index - 1, temp);
    } else {
        console.warn("Index √©tendu hors bornes :", index);
    }
}

// Configuration du graphique (√† placer avant la fonction initChart)
function initChart() {
    const canvas = document.getElementById('configTempChart');
    if (!canvas) {
        console.warn("‚ö†Ô∏è √âl√©ment canvas introuvable, tentative retard√©e");
        setTimeout(initChart, 500);
        return;
    }

    const ctx = canvas.getContext('2d');
    if (!ctx) {
        console.warn("‚ö†Ô∏è Contexte canvas introuvable");
        return;
    }

    // üîÅ Cr√©er les donn√©es √©tendues
    extendedTemperatureData = [
        temperatureData[temperatureData.length - 1], // pour lisser la courbe
        ...temperatureData,
        temperatureData[0]
    ];

    const labels = ['23h', '0h', '1h', '2h', '3h', '4h', '5h', '6h', '7h', '8h', '9h', '10h', '11h',
                    '12h', '13h', '14h', '15h', '16h', '17h', '18h', '19h', '20h', '21h', '22h', '23h', '0h'];

    const chartConfig = {
        type: 'line',
        data: {
            labels: labels,
            datasets: [{
                label: 'Temp√©rature (¬∞C)',
                data: extendedTemperatureData,
                borderColor: '#ff6b6b',
                backgroundColor: 'rgba(255, 107, 107, 0.1)',
                borderWidth: 3,
                fill: true,
                tension: 0.3,
                pointBackgroundColor: '#ff6b6b',
                pointBorderColor: '#ffffff',
                pointBorderWidth: 2,
                pointRadius: 8,
                pointHoverRadius: 12
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
                intersect: false,
                mode: 'index'
            },
            plugins: {
                legend: {
                    labels: {
                        color: '#ffffff',
                        font: { size: 14 }
                    }
                },
                title: {
                    display: true,
                    text: 'Courbe d\'√©dition du jour - Cliquez et glissez pour ajuster',
                    color: '#ffffff',
                    font: { size: 18 }
                },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            return `${context.parsed.y.toFixed(1)}¬∞C`;
                        }
                    }
                }
            },
            scales: {
                x: {
                    grid: { color: 'rgba(255, 255, 255, 0.1)' },
                    ticks: { color: '#ffffff' }
                },
                y: {
                    grid: { color: 'rgba(255, 255, 255, 0.1)' },
                    ticks: { color: '#ffffff' },
                    min: function(context) {
                        return Math.min(...context.chart.data.datasets[0].data) - 1;
                    },
                    max: function(context) {
                        return Math.max(...context.chart.data.datasets[0].data) + 1;
                    }
                }
            },
            onHover: (event, activeElements) => {
                event.native.target.style.cursor = activeElements.length > 0 ? 'pointer' : 'crosshair';
            },
            onClick: (event, activeElements) => {
                if (activeElements.length > 0) {
                    const index = activeElements[0].index;
                    const canvasPosition = Chart.helpers.getRelativePosition(event, chart);
                    const dataY = chart.scales.y.getValueForPixel(canvasPosition.y);
                    if (index >= 0 && index <= 25) {
                        const newTemp = Math.max(globalMinTempSet, Math.min(globalMaxTempSet, dataY));
                        updateTemperatureFromExtendedIndex(index, newTemp);
                    }
                }
            }
        }
    };

    // ‚úÖ Initialiser le graphique
    chart = new Chart(ctx, chartConfig);

    // üéõÔ∏è Ajout des √©v√©nements
    canvas.addEventListener('mousedown', startDrag);
    canvas.addEventListener('mousemove', drag);
    canvas.addEventListener('mouseup', endDrag);
    canvas.addEventListener('mouseleave', endDrag);

    canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
    canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
    canvas.addEventListener('touchend', handleTouchEnd, { passive: false });

    // üîÅ Initialiser l'affichage
    updateTempGrid();
    updateStatus();

    // üåê Rendre accessibles les objets globalement
    window.temperatureChart = chart;
    window.temperatureData = temperatureData;
    window.extendedTemperatureData = extendedTemperatureData;
    window.updateTempGrid = updateTempGrid;
    window.updateStatus = updateStatus;
    window.updateChartAndGrid = updateChartAndGrid;
    window.chart = chart;

    console.log("‚úÖ Graphique de temp√©rature initialis√© avec succ√®s");
}

// Fonctions de gestion du drag 
function startDrag(event) {
    isDragging = true;
    drag(event);
    event.preventDefault();
}

function drag(event) {
    if (!isDragging) return;

    const rect = event.target.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;

    const canvasPosition = Chart.helpers.getRelativePosition(event, chart);
    const dataX = chart.scales.x.getValueForPixel(canvasPosition.x);
    const dataY = chart.scales.y.getValueForPixel(canvasPosition.y);

    // Calculer l'index pour 26 heures
    const index = Math.round(dataX);
    if (index >= 0 && index <= 25) {
        const newTemp = Math.max(globalMinTempSet, Math.min(globalMaxTempSet, dataY));
        updateTemperatureFromExtendedIndex(index, newTemp);
    }
    event.preventDefault();
}

function endDrag(event) {
    isDragging = false;
    event.preventDefault();
}

// Gestion tactile pour mobiles/tablettes
let touchStarted = false;

function handleTouchStart(event) {
    touchStarted = true;
    const touch = event.touches[0];
    const mouseEvent = new MouseEvent('mousedown', {
        clientX: touch.clientX,
        clientY: touch.clientY
    });
    startDrag(mouseEvent);
    event.preventDefault();
}

function handleTouchMove(event) {
    if (!touchStarted) return;

    const touch = event.touches[0];
    const mouseEvent = new MouseEvent('mousemove', {
        clientX: touch.clientX,
        clientY: touch.clientY
    });

    const rect = mouseEvent.target.getBoundingClientRect();
    const x = touch.clientX - rect.left;
    const y = touch.clientY - rect.top;

    const canvasPosition = Chart.helpers.getRelativePosition(mouseEvent, chart);
    const dataX = chart.scales.x.getValueForPixel(canvasPosition.x);
    const dataY = chart.scales.y.getValueForPixel(canvasPosition.y);

    // Calculer l'index pour 26 heures
    const index = Math.round(dataX);
    if (index >= 0 && index <= 25) {
        const newTemp = Math.max(globalMinTempSet, Math.min(globalMaxTempSet, dataY));
        updateTemperatureFromExtendedIndex(index, newTemp);
    }
    event.preventDefault();
}

function handleTouchEnd(event) {
    touchStarted = false;
    const mouseEvent = new MouseEvent('mouseup', {});
    endDrag(mouseEvent);
    event.preventDefault();
}

// Fonction updateTemperature
function updateTemperature(hour, temp) {
    // Validation selon vos limites backend (globalMinTempSet-globalMaxTempSet¬∞C pour la s√©curit√©)
    temp = Math.max(globalMinTempSet, Math.min(globalMaxTempSet, temp));

    // Assurez-vous que l'index est dans la plage correcte pour temperatureData
    if (hour >= 0 && hour < temperatureData.length) {
        temperatureData[hour] = temp;
    } else {
        console.error("Index de l'heure hors limites pour temperatureData");
        return;
    }

    // Mettre √† jour les donn√©es √©tendues
    extendedTemperatureData = [temperatureData[temperatureData.length - 1], ...temperatureData, temperatureData[0]];

    // Mettre √† jour le graphique
    chart.data.datasets[0].data = [...extendedTemperatureData];
    chart.update('none'); // 'none' pour une animation plus fluide pendant le drag

    // Mettre √† jour l'affichage
    // updateTempGrid();
    updateStatus();

    // Exposer la mise √† jour globalement
    window.temperatureData = temperatureData;
    window.extendedTemperatureData = extendedTemperatureData;
}

// Fonction updateTempGrid
function updateTempGrid() {
    const grid = document.getElementById('temperatureChart');

    if (!grid) {
        console.warn("‚ö†Ô∏è √âl√©ment 'temperatureChart' non trouv√©");
        return;
    }

    // Vider le contenu existant
    grid.innerHTML = '';

    // Utiliser extendedTemperatureData si vous avez 26 heures
    extendedTemperatureData.forEach((temp, hour) => {
        const hourLabel = hour === 0 ? '23h' : hour <= 24 ? `${hour - 1}h` : '0h';
        const hourControl = document.createElement('div');
        hourControl.className = `hour-control ${hour === currentHour + 1 ? 'current-hour' : ''}`;
        hourControl.innerHTML = `
            <div class="hour-label">${hourLabel}</div>
            <div class="hour-temp">${temp.toFixed(1)}¬∞C</div>
        `;

        // Gestionnaire de clic pour modification manuelle
        hourControl.onclick = () => {
            const displayHour = hour === 0 ? '23h' : hour <= 24 ? `${hour - 1}h` : '0h';
            const newTemp = prompt(`Temp√©rature pour ${displayHour} (${globalMinTempSet}-${globalMaxTempSet}¬∞C):`, temp.toFixed(1));
            if (newTemp && !isNaN(newTemp)) {
                const validTemp = Math.max(globalMinTempSet, Math.min(globalMaxTempSet, parseFloat(newTemp)));
                updateTemperature(hour, validTemp);

                if (validTemp !== parseFloat(newTemp)) {
                    alert(`Temp√©rature ajust√©e √† ${validTemp}¬∞C (limite de s√©curit√© ${globalMinTempSet}-${globalMaxTempSet}¬∞C)`);
                }
            }
        };

        grid.appendChild(hourControl);
    });
}

// Fonction de validation de l'initialisation
function validateChartInitialization() {
    const checks = [
        { name: 'Canvas element', check: () => document.getElementById('temperatureChart') !== null },
        { name: 'Chart object', check: () => typeof chart !== 'undefined' && chart !== null },
        { name: 'Temperature data', check: () => Array.isArray(temperatureData) && temperatureData.length === 24 },
        { name: 'Global variables', check: () => window.temperatureData && window.temperatureChart },
    ];
    
    const results = checks.map(check => ({
        name: check.name,
        passed: check.check()
    }));
    
    const allPassed = results.every(result => result.passed);
    
    console.log('üîç Validation de l\'initialisation du graphique:');
    results.forEach(result => {
        console.log(`  ${result.passed ? '‚úÖ' : '‚ùå'} ${result.name}`);
    });
    
    if (allPassed) {
        console.log('‚úÖ Graphique enti√®rement fonctionnel');
    } else {
        console.warn('‚ö†Ô∏è Probl√®mes d√©tect√©s dans l\'initialisation');
    }
    
    return allPassed;
}

function applyPreset(preset) {
    switch(preset) {
        case 'mer':
            temperatureData = Array(24).fill(0).map((_, i) => {
                if (i >= 6 && i < 10) return 26;
                if (i >= 10 && i < 16) return 29;
                if (i >= 16 && i < 22) return 26;
                return 24;
            });
            break;
        case 'foret':
            temperatureData = Array(24).fill(0).map((_, i) => {
                if (i >= 6 && i < 10) return 24;
                if (i >= 10 && i < 16) return 28;
                if (i >= 16 && i < 22) return 25;
                return 23;
            });
            break;
        case 'tropical':
            temperatureData = Array(24).fill(0).map((_, i) => {
                return 28 + Math.sin((i - 8) / 24 * Math.PI * 2) * 4;
            });
            break;
        case 'desert':
            temperatureData = Array(24).fill(0).map((_, i) => {
                if (i >= 6 && i < 9) return 27;
                if (i >= 9 && i < 17) return 32;
                if (i >= 17 && i < 23) return 28;
                return 23;
            });
            break;
        case 'copie':
            // Afficher un message de chargement dans la console
            console.log('üå°Ô∏è R√©cup√©ration des donn√©es m√©t√©o en cours...');
            
            // Appeler la fonction de r√©cup√©ration des donn√©es m√©t√©o
            fetchLocalDataAndUpdateCurve()
                .then(() => {
                    console.log('‚úÖ Donn√©es m√©t√©o appliqu√©es avec succ√®s');
                })
                .catch(error => {
                    console.error('‚ùå Erreur lors de l\'application des donn√©es m√©t√©o:', error);
                    alert('Erreur lors de la r√©cup√©ration des donn√©es m√©t√©o: ' + error.message);
                });
            return; // Sortir ici car la mise √† jour se fait de mani√®re asynchrone
        case 'constant':
            temperatureData = Array(24).fill(25);
            break;
        default:
            // Mise √† jour pour tous les autres cas

            break;
    }
    
    reapplyTemperatureLimits();
    updateChartAndGrid();
}

// Fonction helper pour centraliser la mise √† jour 
function updateChartAndGrid() {
    extendedTemperatureData = [temperatureData[temperatureData.length - 1], ...temperatureData, temperatureData[0]];
    if (typeof chart !== 'undefined' && chart !== null) {
        chart.data.datasets[0].data = [...extendedTemperatureData];
        chart.update();
        console.log("üìä Graphique mis √† jour avec nouvelles donn√©es");
    } else {
        console.warn("‚ö†Ô∏è Graphique non initialis√© pour la mise √† jour");
    }
    
    if (typeof updateTempGrid === 'function') {
        // updateTempGrid();
    } else {
        console.warn("‚ö†Ô∏è Fonction updateTempGrid non disponible");
    }
    
    if (typeof updateStatus === 'function') {
        updateStatus();
    } else {
        console.warn("‚ö†Ô∏è Fonction updateStatus non disponible");
    }
    
    // Mettre √† jour les variables globales
    window.extendedTemperatureData = extendedTemperatureData;
    window.temperatureData = temperatureData;
    window.temperatureChart = chart;
}

// Nouvelle fonction pour g√©rer la r√©cup√©ration et mise √† jour
async function fetchLocalDataAndUpdateCurve() {
    try {
        // V√©rifier que les coordonn√©es sont disponibles
        const lat = document.getElementById('latInput').value;
        const lon = document.getElementById('lonInput').value;

        if (!lat || !lon) {
            throw new Error("Veuillez saisir les coordonn√©es latitude/longitude dans les param√®tres m√©t√©o");
        }

        // Appeler la fonction de r√©cup√©ration des donn√©es
        const result = await fetchLocalData();

        // Mettre √† jour la courbe avec les donn√©es r√©cup√©r√©es
        if (result && result.temperatures) {
            let temperatures = result.temperatures;
            const minTemp = Math.min(...temperatures);
            const maxTemp = Math.max(...temperatures);

            // V√©rifier les limites de temp√©rature
            if (minTemp < globalMinTempSet || maxTemp > globalMaxTempSet) {
                alert(`‚ö†Ô∏è Attention: Les temp√©ratures d√©passent les limites d√©finies (${globalMinTempSet}¬∞C - ${globalMaxTempSet}¬∞C). Les valeurs seront ajust√©es.`);
                // Appliquer les limitations
                temperatures = temperatures.map(temp => Math.max(globalMinTempSet, Math.min(globalMaxTempSet, temp)));
            }

            temperatureData = temperatures;
            updateChartAndGrid();

            // Afficher un message de succ√®s
            const adjustedMinTemp = Math.min(...temperatureData).toFixed(1);
            const adjustedMaxTemp = Math.max(...temperatureData).toFixed(1);
            alert(`‚úÖ Courbe mise √† jour avec les donn√©es m√©t√©o !\nTemp√©ratures ajust√©es: ${adjustedMinTemp}¬∞C √† ${adjustedMaxTemp}¬∞C`);
        }

        return result;
    } catch (error) {
        console.error('Erreur dans fetchLocalDataAndUpdateCurve:', error);
        throw error;
    }
}

// Fonctions pour l'indicateur de chargement
function showLoadingIndicator() {
    const indicator = document.createElement('div');
    indicator.id = 'loadingIndicator';
    indicator.innerHTML = '<div style="text-align: center; padding: 20px; color: #fff;">Traitement des donn√©es</div>';
    document.body.appendChild(indicator);
}

function hideLoadingIndicator() {
    const indicator = document.getElementById('loadingIndicator');
    if (indicator) {
        indicator.remove();
    }
}

function smoothCurve() {
	// Lissage avec moyenne mobile
	const smoothed = [...temperatureData];
	for (let i = 1; i < 23; i++) {
		smoothed[i] = (temperatureData[i-1] + temperatureData[i] + temperatureData[i+1]) / 3;
	}
	temperatureData = smoothed;
    let extendedTemperatureData = [temperatureData[temperatureData.length - 1], ...temperatureData, temperatureData[0]];
	chart.data.datasets[0].data = [...extendedTemperatureData];
	chart.update();
	updateTempGrid();
}

function resetToDefault() {
     
	temperatureData = Array(24).fill(0).map((_, i) => 24 + Math.sin(i-6 / 24 * Math.PI * 2) * 6);
    let extendedTemperatureData = [temperatureData[temperatureData.length - 1], ...temperatureData, temperatureData[0]];
	chart.data.datasets[0].data = [...extendedTemperatureData];
	chart.update();
	updateTempGrid();
	updateStatus();
}

// ‚úÖ sauvegarder le profil
async function saveProfile() {
    try {
        // 1. Demander le nom du profil
        const name = prompt('Nom du profil :', 'Profil_' + new Date().toISOString().slice(0,10));
        if (!name || !/^[\w\d _-]+$/.test(name)) {
            alert('‚õî Nom invalide (lettres, chiffres, espace, - et _ autoris√©s)');
            return;
        }

        // 2. D√©tection du mode saisonnier et pr√©sence des donn√©es
        const seasonalMode = document.getElementById("seasonalMode")?.checked || false;
        const isSeasonalProfile = seasonalMode && (Array.isArray(window.seasonalData) && window.seasonalData.length === 366);

        // 3. Construction du profil complet
        const get = (id) => document.getElementById(id);
        const color = $("#color-picker").spectrum("get")?.toHexString() || "#ffffff";
        let ledRed = 255, ledGreen = 255, ledBlue = 255;
        try {
            ledRed = parseInt(color.substr(1, 2), 16);
            ledGreen = parseInt(color.substr(3, 2), 16);
            ledBlue = parseInt(color.substr(5, 2), 16);
        } catch (e) { /* defaults already set */ }

        // R√©cup√©ration de la courbe 24h
        let temperatureData = window.temperatureData || Array(24).fill(22);

        // Construction de l‚Äôobjet profil
        const profile = {
            name: name,
            timestamp: new Date().toISOString(),
            version: "2.0",
            profileType: isSeasonalProfile ? "saisonnier" : "journalier",
            isComplete: true,

            // Temp√©ratures
            temperatures: Array.from(temperatureData),

            // Param√®tres de r√©gulation
            usePWM: get("usePWM")?.checked || false,
            hysteresis: parseFloat(get("hysteresisSet")?.value ?? 0.3),
            Kp: parseFloat(get("KpSet")?.value ?? 2.0),
            Ki: parseFloat(get("KiSet")?.value ?? 5.0),
            Kd: parseFloat(get("KdSet")?.value ?? 1.0),

            // Limites
            useLimitTemp: get("useLimitTemp")?.checked || false,
            globalMinTempSet: parseFloat(get("minTempSet")?.value ?? 15),
            globalMaxTempSet: parseFloat(get("maxTempSet")?.value ?? 35),

            // M√©t√©o
            weatherModeEnabled: get("weatherMode")?.checked || false,
            latitude: parseFloat(get("latInput")?.value ?? 48.85),
            longitude: parseFloat(get("lonInput")?.value ?? 2.35),

            // Saisonnier
            seasonalModeEnabled: seasonalMode,

            // Cam√©ra
            cameraEnabled: get("showCamera")?.checked || false,
            cameraResolution: get("cameraResolution")?.value ?? "qvga",

            // LED
            ledState: get("led-toggle")?.checked || false,
            ledBrightness: parseInt(get("brightness-slider")?.value ?? 255),
            ledRed, ledGreen, ledBlue,

            // Debug
            debugModeEnabled: get("debugMode")?.checked || false
        };

        // 4. Ajout automatique de la courbe saisonni√®re si mode saison activ√©
        if (isSeasonalProfile) {
            if (window.seasonalData.every(day =>
                Array.isArray(day) && day.length === 24 && day.every(v => typeof v === 'number' && !isNaN(v))
            )) {
                // Deep copy pour √©viter toute mutation ult√©rieure
                profile.seasonalData = JSON.parse(JSON.stringify(window.seasonalData));
            } else {
                alert("‚ö†Ô∏è Les donn√©es saisonni√®res sont corrompues ou incompl√®tes. Le profil sera sauvegard√© sans la courbe annuelle !");
            }
        }

        // 5. Optionnel : estimation de la taille
        const profileStr = JSON.stringify(profile, null, 2);
        if (profileStr.length > 100000) {
            if (!confirm(`Le profil g√©n√©r√© fait plus de ${Math.round(profileStr.length/1024)} Ko. Voulez-vous continuer ?`)) {
                return;
            }
        }

        // 6. Envoi au backend
        const response = await fetch('/saveProfile', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: profileStr
        });

        if (response.status === 507) {
            // Espace insuffisant
            const err = await response.json();
            alert(`‚ùå Espace insuffisant sur l'appareil pour sauvegarder ce profil (${Math.round(err.requiredBytes/1024)} Ko n√©cessaires)`);
            // Optionnel : proposer d‚Äôouvrir la page de gestion des profils pour supprimer des anciens
            return;
        } else if (!response.ok) {
            const msg = await response.text();
            alert("‚ùå Erreur lors de la sauvegarde :\n" + msg);
            return;
        }

        alert('‚úÖ Profil sauvegard√© avec succ√®s !');
        if (typeof refreshProfileList === "function") refreshProfileList();
    } catch (error) {
        alert('‚ùå Erreur inattendue : ' + (error.message || error));
        if (window.debugMode) console.error(error);
    }
}


// ‚úÖ Fonction unifi√©e pour sauvegarder les profils
async function saveProfileToBackend(profileData) {
    try {
        const response = await fetch('/saveProfile', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(profileData)
        });
        
        if (response.status === 507) {
            // Espace insuffisant - d√©clencher le nettoyage interactif
            const errorData = await response.json();
            if (typeof handleInsufficientSpace === 'function') {
                handleInsufficientSpace(errorData.requiredBytes);
            } else {
                alert(`‚ùå Espace insuffisant: ${errorData.message}`);
            }
            return;
        }
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const result = await response.text();
        alert('‚úÖ ' + result);
        
        // Rafra√Æchir la liste des profils
        if (typeof refreshProfileList === 'function') {
            refreshProfileList();
        }
        
    } catch (error) {
        console.error('‚ùå Erreur sauvegarde profil:', error);
        alert('‚ùå Erreur lors de la sauvegarde: ' + error.message);
    }
}

// ‚úÖ Rafra√Æchir la liste HTML des profils dans la page
async function refreshProfileList() {
    const ul = document.getElementById('profileList');
    if (!ul) return;
    
    ul.innerHTML = '<li>Chargement...</li>';

    try {
        // Utiliser l'endpoint d√©taill√© s'il existe, sinon l'endpoint standard
        let response = await fetch('/listProfilesDetailed');
        if (!response.ok) {
            response = await fetch('/listProfiles');
        }
        
        const profiles = await response.json();

        ul.innerHTML = '';
        
        if (profiles.length === 0) {
            ul.innerHTML = '<li class="text-gray-500">Aucun profil trouv√©</li>';
            return;
        }
        
        profiles.forEach(profile => {
            const li = document.createElement('li');
            li.classList.add('flex', 'justify-between', 'items-center', 'border-b', 'pb-1');

            // D√©terminer le type de profil
            const profileType = getProfileType(profile);
            const profileName = profile.name || profile;
            
            li.innerHTML = `
                <div class="flex-1">
                    <div class="font-medium">${profileName}</div>
                    ${profile.sizeFormatted ? `
                        <div class="text-xs text-gray-500">
                            ${profileType} ‚Ä¢ ${profile.sizeFormatted} ‚Ä¢ ${profile.lastModifiedFormatted || ''}
                        </div>
                    ` : ''}
                </div>
                <div class="flex space-x-1">
                    <button onclick="loadNamedProfile('${profileName}')" title="Charger">üìÇ</button>
                    <button onclick="renameProfile('${profileName}')" title="Renommer">‚úèÔ∏è</button>
                    <button onclick="deleteProfile('${profileName}')" title="Supprimer">üóëÔ∏è</button>
                    <a href="/downloadProfile?name=${encodeURIComponent(profileName)}" download title="T√©l√©charger">‚¨áÔ∏è</a>
                </div>
            `;
            ul.appendChild(li);
        });
        
    } catch (error) {
        ul.innerHTML = '<li class="text-red-500">Erreur de chargement</li>';
        console.error('Erreur liste profils:', error);
    }
}

// ‚úÖ Fonction pour d√©terminer le type de profil
function getProfileType(profile) {
    if (typeof profile === 'string') {
        return 'üìä Complet';
    }
    
    if (profile.hasSeasonal || profile.profileType === 'saisonnier') {
        return 'üåç Saisonnier';
    }
    
    if (profile.type) {
        return profile.type;
    }
    
    // Estimation bas√©e sur la taille
    if (profile.size) {
        if (profile.size > 50000) {
            return 'üåç Saisonnier';
        }
    }
    
    return '‚öôÔ∏è Complet';
}



// ‚úÖ Fonction pour appliquer un profil complet √† l'interface
async function applyCompleteProfileToUI(profileData) {
    try {
        // 1. Temp√©ratures 24h (courbe du jour)
        if (Array.isArray(profileData.temperatures) && profileData.temperatures.length === 24) {
            window.temperatureData = [...profileData.temperatures];
            if (typeof updateChartAndGrid === 'function') updateChartAndGrid();
        }

        // 2. Saisonnier : seasonalData (366 x 24), si pr√©sent
        if (Array.isArray(profileData.seasonalData) && profileData.seasonalData.length === 366) {
            // Validation rapide des sous-tableaux
            let isValid = profileData.seasonalData.every(day =>
                Array.isArray(day) && day.length === 24 && day.every(val => typeof val === "number" && !isNaN(val))
            );
            if (isValid) {
                window.seasonalData = profileData.seasonalData.map(day => [...day]);
                if (typeof createHeatmap === "function") createHeatmap(window.seasonalData);
            } else {
                alert("‚ö†Ô∏è Courbe saisonni√®re du profil corrompue‚ÄØ: elle ne sera pas appliqu√©e.");
            }
        }

        // 3. Param√®tres de r√©gulation
        setElementValue("usePWM", profileData.usePWM, 'checkbox');
        setElementValue("hysteresisSet", profileData.hysteresis);
        setElementValue("KpSet", profileData.Kp);
        setElementValue("KiSet", profileData.Ki);
        setElementValue("KdSet", profileData.Kd);

        // 4. Limites
        setElementValue("useLimitTemp", profileData.useLimitTemp, 'checkbox');
        setElementValue("minTempSet", profileData.globalMinTempSet);
        setElementValue("maxTempSet", profileData.globalMaxTempSet);

        // 5. M√©t√©o
        setElementValue("weatherMode", profileData.weatherModeEnabled, 'checkbox');
        setElementValue("latInput", profileData.latitude);
        setElementValue("lonInput", profileData.longitude);

        // 6. Saisonnier (switch UI)
        setElementValue("seasonalMode", profileData.seasonalModeEnabled, 'checkbox');
        // Optionnel : forcer la visibilit√© saisonni√®re
        if (typeof updateSeasonalVisibility === "function") updateSeasonalVisibility();

        // 7. Cam√©ra
        setElementValue("showCamera", profileData.cameraEnabled, 'checkbox');
        setElementValue("cameraResolution", profileData.cameraResolution);

        // 8. LED
        setElementValue("led-toggle", profileData.ledState, 'checkbox');
        setElementValue("brightness-slider", profileData.ledBrightness);
        setElementValue("brightness-value", profileData.ledBrightness, 'text');
        // Couleur LED
        if (
            typeof profileData.ledRed === "number" &&
            typeof profileData.ledGreen === "number" &&
            typeof profileData.ledBlue === "number"
        ) {
            const hexColor = rgbToHex(profileData.ledRed, profileData.ledGreen, profileData.ledBlue);
            try {
                $("#color-picker").spectrum("set", hexColor);
            } catch (error) {
                console.warn('Impossible d\'appliquer la couleur LED:', error);
            }
        }

        // 9. Debug (si pr√©sent)
        if (profileData.debugModeEnabled !== undefined)
            setElementValue("debugMode", profileData.debugModeEnabled, 'checkbox');

        // 10. Synchronisation UI globale
        if (typeof updateLedDot === 'function') updateLedDot();
        if (typeof updateVisibility === 'function') updateVisibility();
        if (typeof reapplyTemperatureLimits === 'function') reapplyTemperatureLimits();

        // 11. Heatmap saisonni√®re (si pr√©sente et mode actif)
        if (
            profileData.seasonalModeEnabled &&
            typeof window.seasonalData !== "undefined" &&
            Array.isArray(window.seasonalData) &&
            typeof createHeatmap === "function"
        ) {
            createHeatmap(window.seasonalData);
            // S√©lection du jour courant pour √©dition, si besoin :
            if (typeof updateSeasonalVisibility === "function") updateSeasonalVisibility();
        }

        // 12. Log
        if (window.debugMode)
            console.log('‚úÖ Profil complet appliqu√© √† l\'interface utilisateur', profileData);
    } catch (e) {
        alert('‚ùå Erreur application du profil : ' + e.message);
        if (window.debugMode) console.error(e);
    }
}

// ‚úÖ Charger un profil par nom (utilis√© dans la liste)
async function loadNamedProfile(name) {
    let previousCursor = document.body.style.cursor;
    try {
        // D√©sactiver l‚ÄôUI pendant le chargement
        document.body.style.cursor = "wait";
        const notif = document.createElement('div');
        notif.textContent = "‚è≥ Chargement du profil...";
        notif.id = "profile-loading-notif";
        notif.style = "position:fixed;top:10px;right:10px;z-index:1000;background:#222;color:#fff;padding:10px;border-radius:6px";
        document.body.appendChild(notif);

        const url = '/loadNamedProfile?name=' + encodeURIComponent(name);
        const res = await fetch(url);

        if (!res.ok) throw new Error('Profil non trouv√© ou illisible');

        const profile = await res.json();

        // Appliquer TOUTES les options du profil
        await applyCompleteProfileToUI(profile);

        // Optionnel : Scroll vers la heatmap ou la zone √©dition si mode saison
        if (profile.seasonalModeEnabled && document.getElementById('seasonalHeatmap')) {
            document.getElementById('seasonalHeatmap').scrollIntoView({ behavior: 'smooth', block: 'center' });
        } else if (document.getElementById('temperatureChart')) {
            document.getElementById('temperatureChart').scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        // Optionnel‚ÄØ: refresh liste des profils
        if (typeof refreshProfileList === "function") refreshProfileList();

        if (window.debugMode) console.log("‚úÖ Profil charg√© :", profile);

        alert('‚úÖ Profil charg√© : ' + name);
    } catch (e) {
        alert('‚ùå ' + e.message);
        console.error("Erreur chargement profil:", e);
    } finally {
        // Restaure l‚ÄôUI
        document.body.style.cursor = previousCursor;
        const n = document.getElementById('profile-loading-notif');
        if (n) n.remove();
    }
}


// Helper pour fixer la valeur d‚Äôun √©l√©ment DOM
function setElementValue(elementId, value, type = 'input') {
    const element = document.getElementById(elementId);
    if (!element) {
        if (window.debugMode) console.warn(`√âl√©ment ${elementId} non trouv√©`);
        return;
    }
    switch (type) {
        case 'checkbox':
            element.checked = Boolean(value);
            break;
        case 'text':
            element.textContent = value;
            break;
        default:
            element.value = value;
            break;
    }
}

// Helper hex pour la couleur LED
function rgbToHex(r, g, b) {
    return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
}


// ‚úÖ Fonction helper pour d√©finir la valeur d'un √©l√©ment
function setElementValue(elementId, value, type = 'input') {
    const element = document.getElementById(elementId);
    if (!element) {
        console.warn(`√âl√©ment ${elementId} non trouv√©`);
        return;
    }
    
    switch (type) {
        case 'checkbox':
            element.checked = Boolean(value);
            break;
        case 'text':
            element.textContent = value;
            break;
        default:
            element.value = value;
            break;
    }
}

// ‚úÖ Supprimer un profil
async function deleteProfile(name) {
    if (!confirm(`Supprimer le profil "${name}" ?`)) return;
    await fetch(`/deleteProfile?name=${encodeURIComponent(name)}`);
    refreshProfileList();
}

// ‚úÖ Renommer un profil
async function renameProfile(oldName) {
    let newName = prompt("Nouveau nom :", oldName.replace('.json', ''));
    if (!newName || newName === oldName) return;
    if (!newName || !/^[\w\d _-]+$/.test(newName)) {
        alert('‚õî Nom invalide (lettres, chiffres, espace, - et _ autoris√©s)');
        return;
    }

    const res = await fetch(`/renameProfile?from=${encodeURIComponent(oldName)}&to=${encodeURIComponent(newName)}`);
    if (res.ok) {
        alert('‚úÖ Profil renomm√©');
        refreshProfileList();
    } else {
        alert('‚ùå Erreur lors du renommage');
    }
}

// ‚úÖ Charger un profil via prompt
async function loadProfile() {
    try {
        const res = await fetch('/listProfiles');
        if (!res.ok) throw new Error('Erreur r√©seau');
        const profiles = await res.json();

        if (!profiles.length) {
            alert('‚ùå Aucun profil personnalis√© trouv√©');
            return;
        }

        const name = prompt("Choisir un profil √† charger :\n" + profiles.join('\n'));
        if (!name || !profiles.includes(name)) {
            alert('‚õî Profil invalide ou annul√©');
            return;
        }

        await loadNamedProfile(name);

    } catch (err) {
        alert('‚ùå Erreur : ' + err.message);
    }
}

// Importer un fichier JSON depuis l'utilisateur
document.getElementById('profileUpload').addEventListener('change', async (event) => {
	const file = event.target.files[0];
	if (!file) return;

	const reader = new FileReader();
	reader.onload = async function (e) {
		try {
			const json = JSON.parse(e.target.result);
			if (!json.name || !json.temperatures) throw new Error("Format invalide");

			const response = await fetch('/uploadProfile', {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify(json)
			});
			if (response.ok) {
				alert("‚úÖ Profil import√©");
				refreshProfileList();
			} else {
				alert("‚ùå Erreur lors de l'importation");
			}
		} catch (e) {
			alert("‚ùå Fichier invalide : " + e.message);
		}
	};
	reader.readAsText(file);
});

// Dans configuration.js - remplacer loadFromDevice() par:
async function loadFromDevice() {
    if (!chart) {
        console.warn("‚è≥ Chart non encore pr√™t, tentative retard√©e...");
        setTimeout(loadFromDevice, 400);
        return;
    }

    try {
        // 1. Charger la courbe de temp√©rature
        const response = await fetch('/getTempCurve');
        if (response.ok) {
            const data = await response.json();
            temperatureData = data;
            extendedTemperatureData = [
                temperatureData[temperatureData.length - 1],
                ...temperatureData,
                temperatureData[0]
            ];
            chart.data.datasets[0].data = extendedTemperatureData;
            chart.update();
            updateTempGrid();
            updateStatus();
            reapplyTemperatureLimits();
        }
        
               
    } catch (error) {
        console.error("‚ùå Erreur lors du chargement des donn√©es :", error);
    }
}

// Fonction pour mettre √† jour l'heure actuelle
function updateCurrentHour() {
    const newHour = new Date().getHours();
    if (newHour !== currentHour) {
        currentHour = newHour;
        updateTempGrid();
        updateStatus();
        console.log(`üïê Heure mise √† jour: ${currentHour}h`);
    }
}

// Fonction pour valider les coordonn√©es
function validateCoordinates(lat, lon) {
  const latitude = parseFloat(lat);
  const longitude = parseFloat(lon);
  
  if (isNaN(latitude) || isNaN(longitude)) {
    return { valid: false, message: "Coordonn√©es invalides" };
  }
  
  if (latitude < -90 || latitude > 90) {
    return { valid: false, message: "Latitude doit √™tre entre -90 et 90" };
  }
  
  if (longitude < -180 || longitude > 180) {
    return { valid: false, message: "Longitude doit √™tre entre -180 et 180" };
  }
  
  return { valid: true };
}

function reapplyTemperatureLimits() {
    const useLimit = document.getElementById("useLimitTemp").checked;
    if (!useLimit) return;

    const min = parseFloat(document.getElementById("minTempSet").value);
    const max = parseFloat(document.getElementById("maxTempSet").value);

    temperatureData = temperatureData.map(temp =>
        Math.min(max, Math.max(min, temp))
    );

    updateChartAndGrid();
}
// Fonction pour mettre √† jour les valeurs globales
function updateGlobalTemps() {
    const minTempInput = document.getElementById("minTempSet");
    const maxTempInput = document.getElementById("maxTempSet");

    globalMinTempSet = parseFloat(minTempInput.value) || 0;
    globalMaxTempSet = parseFloat(maxTempInput.value) || 40;

    console.log(`Temp√©ratures mises √† jour : Min = ${globalMinTempSet}, Max = ${globalMaxTempSet}`);
}

function updateStatus() {
}

function saveConfigurationled() {
	const state = ledToggle.checked;
	const brightness = brightnessSlider.value;
	const color = $("#color-picker").spectrum("get").toHexString();

	// Conversion de la couleur hexad√©cimale en composantes RGB
	const red = parseInt(color.substr(1, 2), 16);
	const green = parseInt(color.substr(3, 2), 16);
	const blue = parseInt(color.substr(5, 2), 16);

	// Envoi des param√®tres au serveur
	fetch(`/updateLed?state=${state}&brightness=${brightness}&red=${red}&green=${green}&blue=${blue}`)
		.then(response => response.text())
		.then(data => console.log(data))
		.catch(error => console.error('Erreur:', error));
}


//main.js
let globalMinTempSet = 0;
let globalMaxTempSet = 40;
let tempChart, humidityChart;
let refreshInterval; 
let cameraEnabled = false;
let cameraResolution = "qvga";

const brightnessValue = document.getElementById('brightness-value');
const ledDot = document.getElementById('led-dot');
const brightnessSlider = document.getElementById('brightness-slider');
const ledToggle = document.getElementById('led-toggle');
const colorPicker = document.getElementById('color-picker');

const resolutionDimensions = {
    'qvga': { width: 320, height: 240 },
    'vga': { width: 640, height: 480 },
    'svga': { width: 800, height: 600 }
};

// V√©rifier la compatibilit√© MJPEG
fetch('/mjpeg-info')
    .then(response => response.json())
    .then(data => {
        console.log('MJPEG Info:', data);
        if (data.compatible) {
            console.log(`‚úÖ MJPEG compatible - FPS estim√©: ${data.estimated_fps}`);
        }
    });

// Red√©marrer le stream en cas d'erreur
document.getElementById('mjpegStream').onerror = function() {
    console.log('üîÑ Red√©marrage stream MJPEG');
    setTimeout(() => {
        this.src = '/mjpeg?' + new Date().getTime();
    }, 1000);
};




// Rafra√Æchissement automatique de l'image capture
function refreshCapture() {
    const img = document.getElementById('cameraCapture');
    img.src = '/capture?' + new Date().getTime(); // Cache busting
}

// Rafra√Æchir toutes les 100ms (10 FPS)
setInterval(refreshCapture, 100);

// Ajuster la vitesse dynamiquement
function setCameraSpeed(fps) {
    fetch(`/setCameraSpeed?fps=${fps}`)
        .then(response => response.text())
        .then(data => console.log('Vitesse ajust√©e:', data));
}



function setStreamDimensions(resolution) {
    const dimensions = resolutionDimensions[resolution];
    const camStream = document.getElementById('camStream');
    if (dimensions && camStream) {
        camStream.style.width = `${dimensions.width}px`;
        camStream.style.height = 'auto'; // Garde le ratio, important pour la responsivit√©
        camStream.style.maxWidth = '100%'; // Assure que l'image ne d√©passe pas son conteneur
    }
}

class ConfigManager {
    constructor() {
        this.config = {};
        this.isLoaded = false;
    }

    async loadConfig() {
        if (this.isLoaded) return this.config;
        
        try {
            const response = await fetch('/getCurrentConfig');
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            
            this.config = await response.json();
            this.isLoaded = true;
            
            // Synchroniser les variables globales
            this.syncGlobalVariables();
            
            return this.config;
        } catch (error) {
            console.error('Erreur chargement config:', error);
            // Utiliser des valeurs par d√©faut en cas d'erreur
            this.config = this.getDefaultConfig();
            this.isLoaded = true;
            return this.config;
        }
    }

    syncGlobalVariables() {
        // Synchroniser avec les variables globales existantes
        globalMinTempSet = this.config.globalMinTempSet || 15;
        globalMaxTempSet = this.config.globalMaxTempSet || 35;
        cameraEnabled = this.config.cameraEnabled || false;
        cameraResolution = this.config.cameraResolution || "qvga";
    }

    getDefaultConfig() {
        return {
            hysteresis: 0.3,
            Kp: 2.0, Ki: 5.0, Kd: 1.0,
            usePWM: false,
            globalMinTempSet: 15,
            globalMaxTempSet: 35,
            latitude: 48.85,
            longitude: 2.35,
            weatherModeEnabled: false,
            cameraEnabled: false,
            useLimitTemp: true,
            tempCurve: Array(24).fill(22),
            ledState: false,
            ledBrightness: 255,
            ledRed: 255, ledGreen: 255, ledBlue: 255
        };
    }

    async saveConfig(updates = {}) {
        this.config = { ...this.config, ...updates };
        
        try {
            const response = await fetch('/applyAllSettings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(this.config)
            });
            
            if (!response.ok) throw new Error('Sauvegarde √©chou√©e');
            return await response.text();
        } catch (error) {
            console.error('Erreur sauvegarde:', error);
            throw error;
        }
    }

    get(key) { return this.config[key]; }
    set(key, value) { this.config[key] = value; }
}

// Instance globale
const configManager = new ConfigManager();

class UpdateManager {
    constructor() {
        this.intervals = [];
    }

    startPeriodicUpdates() {
        console.log('üîÑ D√©marrage des mises √† jour p√©riodiques...');
        
        // V√©rifier que les fonctions existent avant de les appeler
        if (typeof updateData === 'function') {
            this.intervals.push(setInterval(() => updateData(), 5000));
        }
        
        if (typeof updateCurrentHour === 'function') {
            this.intervals.push(setInterval(() => updateCurrentHour(), 60000));
        }
        
        if (typeof updateStatus === 'function') {
            this.intervals.push(setInterval(() => updateStatus(), 10000));
        }
        
        // D√©marrer imm√©diatement une premi√®re mise √† jour
        setTimeout(() => {
            if (typeof updateData === 'function') updateData();
            if (typeof updateStatus === 'function') updateStatus();
        }, 1000);
    }

    stopAllUpdates() {
        this.intervals.forEach(id => clearInterval(id));
        this.intervals = [];
        console.log('‚èπÔ∏è Toutes les mises √† jour p√©riodiques arr√™t√©es');
    }
}

// Dans main.js - ajouter cette fonction
function updateGlobalTemps() {
    const minTempInput = document.getElementById("minTempSet");
    const maxTempInput = document.getElementById("maxTempSet");
    
    if (minTempInput && maxTempInput) {
        globalMinTempSet = parseFloat(minTempInput.value) || 0;
        globalMaxTempSet = parseFloat(maxTempInput.value) || 40;
        
        // Synchroniser avec le ConfigManager
        configManager.set('globalMinTempSet', globalMinTempSet);
        configManager.set('globalMaxTempSet', globalMaxTempSet);
        
        console.log(`Temp√©ratures mises √† jour : Min = ${globalMinTempSet}, Max = ${globalMaxTempSet}`);
    }
}

// Tab switching - Simplifi√© pour 2 onglets seulement
function initTabs() {
	const tabButtons = document.querySelectorAll('.tab-button');
	const dashboardContent = document.getElementById('dashboardContent');
	const configContent = document.getElementById('configContent');
	
	tabButtons.forEach(button => {
		button.addEventListener('click', () => {
			tabButtons.forEach(btn => btn.className = btn.className.replace('tab-active', 'tab-inactive'));
			button.className = button.className.replace('tab-inactive', 'tab-active');
			
			// Hide all content
			dashboardContent.style.display = 'none';
			configContent.style.display = 'none';
			
			// Show selected content
			if (button.id === 'tabDashboard') {
				dashboardContent.style.display = 'block';
			} else if (button.id === 'tabConfig') {
				configContent.style.display = 'block';
				// Initialize seasonal system when config tab is opened
				if (typeof initSeasonalSystem === 'function') {
					initSeasonalSystem();
				}
			}
		});
	});
}

// Data update function fetch
function updateData() {
	fetch("/temperature")
		.then(res => res.text())
		.then(data => {
			if (data !== "--") {
				const timeLabel = new Date().toLocaleTimeString();
				const tempValue = parseFloat(data);
				if (!isNaN(tempValue)) {
					tempChart.data.labels.push(timeLabel);
					tempChart.data.datasets[0].data.push(tempValue);
					
					// Calculate moving average for last 24h (assuming 1 point per 5 seconds = 17280 points per day)
					const windowSize = Math.min(tempChart.data.datasets[0].data.length, 1440); // 24h at 1 point per minute
					const movingAvg = calculateMovingAverage(tempChart.data.datasets[0].data, windowSize);
					tempChart.data.datasets[1].data = movingAvg;
					
					if (tempChart.data.labels.length > 1000) {
						tempChart.data.labels.shift();
						tempChart.data.datasets[0].data.shift();
						tempChart.data.datasets[1].data.shift();
					}
					tempChart.update('none');
					document.getElementById("temperature").innerText = data;
				}
			}
		})
		.catch(err => console.error("Erreur lecture temp√©rature:", err));

	fetch("/humidity")
		.then(res => res.text())
		.then(data => {
			if (data !== "--") {
				const timeLabel = new Date().toLocaleTimeString();
				const humidityValue = parseFloat(data);
				if (!isNaN(humidityValue)) {
					humidityChart.data.labels.push(timeLabel);
					humidityChart.data.datasets[0].data.push(humidityValue);
					
					// Calculate moving average for humidity
					const windowSize = Math.min(humidityChart.data.datasets[0].data.length, 1440);
					const movingAvg = calculateMovingAverage(humidityChart.data.datasets[0].data, windowSize);
					humidityChart.data.datasets[1].data = movingAvg;
					
					if (humidityChart.data.labels.length > 1000) {
						humidityChart.data.labels.shift();
						humidityChart.data.datasets[0].data.shift();
						humidityChart.data.datasets[1].data.shift();
					}
					humidityChart.update('none');
					document.getElementById("humidity").innerText = data;
				}
			}
		})
		.catch(err => console.error("Erreur lecture humidit√©:", err));

	// Update other data 
	fetch("/currentTime")
		.then(res => res.text())
		.then(data => document.getElementById("currentTime").innerText = data)
		.catch(err => console.error("Erreur lecture heure:", err));

	fetch("/setGlobalMaxTemp")
		.then(res => res.text())
		.then(data => document.getElementById("maxTempSet").innerText = data)
		.catch(err => console.error("Erreur lecture temp max:", err));

	fetch("/setGlobalMinTemp")
		.then(res => res.text())
		.then(data => document.getElementById("minTempSet").innerText = data)
		.catch(err => console.error("Erreur lecture temp min:", err));

    fetch("/minHumidite")
        .then(res => {
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            return res.text();
        })
        .then(data => document.getElementById("minHumidite").innerText = data)
        .catch(err => {
            console.warn("Endpoint /minHumidite non disponible:", err.message);
            document.getElementById("minHumidite").innerText = "--";
        });

    fetch("/maxHumidite")
        .then(res => {
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            return res.text();
        })
        .then(data => document.getElementById("maxHumidite").innerText = data)
        .catch(err => {
            console.warn("Endpoint /maxHumidite non disponible:", err.message);
            document.getElementById("maxHumidite").innerText = "--";
        });
	
	fetch("/maxTemperature")
        .then(res => {
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            return res.text();
        })
        .then(data => document.getElementById("maxTemperature").innerText = data)
        .catch(err => {
            console.warn("Endpoint /maxTemperature non disponible:", err.message);
            document.getElementById("maxTemperature").innerText = "--";
        });
		
	fetch("/minTemperature")
        .then(res => {
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            return res.text();
        })
        .then(data => document.getElementById("minTemperature").innerText = data)
        .catch(err => {
            console.warn("Endpoint /minTemperature non disponible:", err.message);
            document.getElementById("minTemperature").innerText = "--";
        });
	
	fetch("/movingAverageHum")
        .then(res => {
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            return res.text();
        })
        .then(data => document.getElementById("movingAverageHum").innerText = data)
        .catch(err => {
            console.warn("Endpoint /movingAverageHum non disponible:", err.message);
            document.getElementById("movingAverageHum").innerText = "--";
        });
	
	fetch("/movingAverageTemp")
        .then(res => {
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            return res.text();
        })
        .then(data => document.getElementById("movingAverageTemp").innerText = data)
        .catch(err => {
            console.warn("Endpoint /movingAverageTemp non disponible:", err.message);
            document.getElementById("movingAverageTemp").innerText = "--";
        });

	fetch("/status")
	  .then(res => res.json())
	  .then(data => {
		const heaterEl = document.getElementById("heaterState");
		const modeEl = document.getElementById("currentMode");
		const consigneEl = document.getElementById("consigneTemp");
		const modeDetailsEl = document.getElementById("modeDetails");

		// Chauffage (output PWM)
		if (data.heaterState !== undefined) {
			const pwmValue = parseInt(data.heaterState);
		  if (data.usePWM) {
			
			heaterEl.innerText = `${data.heaterState}`;
			if (pwmValue > 100) {
				heaterEl.className = "metric-value heater-high";
			} else if (pwmValue > 20 || (!document.getElementById("usePWM").checked && pwmValue > 0)) {
				heaterEl.className = "metric-value heater-medium";
			} else {
				heaterEl.className = "metric-value heater-low";
			}

		  } else {
			heaterEl.innerText = data.heaterState > 0 ? "ON" : "OFF";
			if (pwmValue > 100) {
				heaterEl.className = "metric-value heater-high";
			} else {
				heaterEl.className = "metric-value heater-low";
			}	
		  }
		}

		// Consigne
		if (data.consigne !== undefined) {
		  consigneEl.innerText = `${data.consigne.toFixed(1)}¬∞C`;
		}

		// Mode & d√©tails
		if (data.usePWM) {
		  modeEl.innerText = "PWM";
		  modeDetailsEl.innerText = `Kp=${data.Kp}, Ki=${data.Ki}, Kd=${data.Kd}`;
		} else {
		  modeEl.innerText = "ON/OFF";
		  modeDetailsEl.innerText = `Hyst√©r√©sis = ${data.hysteresis}`;
		}
		console.log("üîç /status JSON:", data);
	  })
	  .catch(err => {
		console.warn("Erreur /status :", err.message);
		document.getElementById("heaterState").innerText = "--";
		document.getElementById("currentMode").innerText = "--";
		document.getElementById("consigneTemp").innerText = "--¬∞C";
		document.getElementById("modeDetails").innerText = "";
	  });
}

// Update LED dot color and brightness
function updateLedDot() {
	const brightness = brightnessSlider.value;
	const color = $("#color-picker").spectrum("get").toHexString();

	if (ledToggle.checked) {
        // La bordure prend la couleur vive
        ledDot.style.border = `2px solid ${color}`;

        // Le fond utilise RGBA pour g√©rer l'opacit√© du remplissage
        const r = parseInt(color.substr(1, 2), 16);
        const g = parseInt(color.substr(3, 2), 16);
        const b = parseInt(color.substr(5, 2), 16);
        const opacity = brightness / 255;
        
        ledDot.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${opacity})`;
        // On s'assure que l'opacit√© globale de l'√©l√©ment est √† 1 pour que la bordure ne soit pas affect√©e
        ledDot.style.opacity = 1;

    } else {
        // Si la LED est √©teinte, pas de bordure et fond noir
        ledDot.style.border = 'none';
        ledDot.style.backgroundColor = '#000';
        ledDot.style.opacity = 1;
    }
}

// Fonction pour convertir RGB en hexad√©cimal
function rgbToHex(r, g, b) {
	return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
}

// ‚úÖ CORRECTION DU STREAM VID√âO - Variables globales pour la gestion de la cam√©ra
let cameraInterval = null;
let isCameraRunning = false;

// ‚úÖ Fonction corrig√©e pour le rafra√Æchissement de la cam√©ra
function cameraRefreshLoop() {
    if (!isCameraRunning) return; // Arr√™ter la boucle si la cam√©ra est d√©sactiv√©e

    const camStream = document.getElementById('camStream');
    if (!camStream) {
        console.warn('‚ùå √âl√©ment camStream non trouv√©');
        isCameraRunning = false;
        return;
    }

    const tempImg = new Image();

    // Si l'image charge avec succ√®s...
    tempImg.onload = () => {
        camStream.src = tempImg.src; // Mettre √† jour l'image visible
        setTimeout(cameraRefreshLoop, 1000); // Programmer la prochaine image dans 1 seconde
    };

    // Si une erreur survient...
    tempImg.onerror = () => {
        console.warn("‚ö†Ô∏è Erreur de chargement de l'image du flux, nouvelle tentative dans 2s...");
        setTimeout(cameraRefreshLoop, 2000); // R√©essayer dans 2 secondes
    };

    // Lancer le chargement de l'image avec timestamp pour √©viter le cache
    tempImg.src = '/capture?' + new Date().getTime();
}

// ‚úÖ Fonction corrig√©e pour la visibilit√© de la cam√©ra
function updateCameraVisibility() {
    const cameraContainer = document.getElementById('cameraContainer');
    const showCamera = document.getElementById('showCamera');

    if (!cameraContainer || !showCamera) {
        console.warn('‚ùå √âl√©ments cam√©ra non trouv√©s');
        return;
    }

    if (showCamera.checked) {
        console.log('üìπ Activation de la cam√©ra...');
        cameraContainer.style.display = 'block';
        cameraEnabled = true;
        
        if (!isCameraRunning) {
            isCameraRunning = true;
            cameraRefreshLoop(); // D√©marrer la boucle de rafra√Æchissement
        }
    } else {
        console.log('üìπ D√©sactivation de la cam√©ra...');
        cameraContainer.style.display = 'none';
        cameraEnabled = false;
        isCameraRunning = false; // Arr√™ter la boucle au prochain tour
    }
}

// Centraliser les √©v√©nements
function initEventListeners() {
    // Gestion sliders et switches
    const minTempInput = document.getElementById("minTempSet");
    const maxTempInput = document.getElementById("maxTempSet");
    
    if (minTempInput) minTempInput.addEventListener("change", updateGlobalTemps);
    if (maxTempInput) maxTempInput.addEventListener("change", updateGlobalTemps);
    
    const useLimitTemp = document.getElementById("useLimitTemp");
    if (useLimitTemp) {
        useLimitTemp.addEventListener("change", () => {
            if (typeof reapplyTemperatureLimits === 'function') reapplyTemperatureLimits();
            if (typeof updateVisibility === 'function') updateVisibility();
        });
    }
    
    const usePWM = document.getElementById("usePWM");
    if (usePWM) usePWM.addEventListener("change", () => {
        if (typeof updateVisibility === 'function') updateVisibility();
    });
    
    const weatherMode = document.getElementById("weatherMode");
    if (weatherMode) weatherMode.addEventListener("change", () => {
        if (typeof updateVisibility === 'function') updateVisibility();
    });

    // Nouveau: Gestion du mode saisonnier
    const seasonalMode = document.getElementById("seasonalMode");
    if (seasonalMode) {
        seasonalMode.addEventListener("change", () => {
            if (typeof updateSeasonalVisibility === 'function') updateSeasonalVisibility();
        });
    }

    const debugMode = document.getElementById("debugMode");
    if (debugMode) {
        debugMode.addEventListener("change", () => {
            const enabled = debugMode.checked;
            fetch(`/setDebugMode?enabled=${enabled ? 1 : 0}`);
            console.log(`[DEBUG] Mode debug ${enabled ? 'activ√©' : 'd√©sactiv√©'}`);
        });
    }
    
    // ‚úÖ CORRECTION - Gestion de la cam√©ra avec la fonction corrig√©e
    const showCamera = document.getElementById("showCamera");
    if (showCamera) {
        showCamera.addEventListener("change", updateCameraVisibility);
        // Appel initial pour d√©finir la visibilit√© au chargement
        updateCameraVisibility(); 
    }
    
    const applyBtn = document.getElementById("applyBtn");
    if (applyBtn) applyBtn.addEventListener("click", () => {
        if (typeof applyAllSettings === 'function') applyAllSettings();
    });

    const brightnessSlider = document.getElementById('brightness-slider');
    const brightnessValue = document.getElementById('brightness-value');
    if (brightnessSlider && brightnessValue) {
        brightnessSlider.addEventListener('input', () => {
            brightnessValue.textContent = brightnessSlider.value;
        });
    }

    // Appel initial pour la visibilit√©
    if (typeof updateVisibility === 'function') {
        updateVisibility();
    }

    const cameraResolutionSelector = document.getElementById('cameraResolution');
    if (cameraResolutionSelector) {
        cameraResolutionSelector.addEventListener('change', (event) => {
            if (typeof setStreamDimensions === 'function') {
                setStreamDimensions(event.target.value);
            }
        });
    }
}

// Fonction l'initialisation de Spectrum
function initSpectrum() {
    return new Promise((resolve) => {
        const colorPicker = $("#color-picker");

        if (!colorPicker.length) {
            console.warn("‚ùå √âl√©ment #color-picker non trouv√© dans le DOM.");
            return resolve(false);
        }

        // Initialisation du color picker
        colorPicker.spectrum({
            preferredFormat: "hex",
            showInput: true,
            showInitial: true,
            showPalette: false,
            showButtons: false,
            cancelText: 'Annuler',
            chooseText: 'Choisir',
            change: updateLedDot
        });

        // üîÅ Attente active jusqu'√† ce que .get() fonctionne
        const checkReady = () => {
            const pickerInstance = colorPicker.spectrum("get");
            if (pickerInstance && typeof pickerInstance.toHexString === "function") {
                console.log("‚úÖ Spectrum initialis√© avec succ√®s");
                resolve(true);
            } else {
                setTimeout(checkReady, 100);
            }
        };

        checkReady();
    });
}

// Dans main.js - Modifier l'ordre d'initialisation
document.addEventListener('DOMContentLoaded', async () => {
    try {
        console.log('üöÄ D√©marrage de l\'application...');

        // 1. Charger la configuration une seule fois
        await configManager.loadConfig();
        console.log('‚úÖ Configuration charg√©e');

        // 2. Initialiser l'interface de base
        initTabs();

        // 3. Initialiser les graphiques
        if (typeof initCharts === 'function') {
            initCharts();
        }

        // 4. Initialiser le graphique de temp√©rature
        if (typeof initChart === 'function') {
            await initChart();
        }

        // 5. ‚úÖ ATTENDRE que Spectrum soit initialis√©
        const ready = await initSpectrum();
        if (!ready) {
            alert("Erreur : le color picker n'a pas pu √™tre initialis√©.");
            return;
        }

        // 6. Maintenant charger l'interface utilisateur avec la config
        if (typeof loadCurrentConfigToUI === 'function') {
            await loadCurrentConfigToUI();
        }

        // 7. D√©marrer les mises √† jour p√©riodiques
        const updateManager = new UpdateManager();
        updateManager.startPeriodicUpdates();

        // 8. Initialisation des √©v√©nements
        initEventListeners();

        console.log('‚úÖ Initialisation compl√®te termin√©e');
    } catch (error) {
        console.error('‚ùå Erreur initialisation:', error);
        alert('Erreur lors de l\'initialisation: ' + error.message);
    }
});



// js/map.js - Carte Leaflet pour la g√©olocalisation
let leafletMapInstance = null;
let leafletMarker = null;
let isMapVisible = false;

// Initialisation de la carte
function initMap() {
    if (leafletMapInstance) {
        return; // Carte d√©j√† initialis√©e
    }
    
    // Position par d√©faut (Paris)
    const defaultLat = 48.8566;
    const defaultLon = 2.3522;
    
    // R√©cup√©rer les coordonn√©es actuelles ou utiliser les valeurs par d√©faut
    const currentLat = parseFloat(document.getElementById('latInput').value) || defaultLat;
    const currentLon = parseFloat(document.getElementById('lonInput').value) || defaultLon;
    
    // Cr√©er la carte
    leafletMapInstance = L.map('map').setView([currentLat, currentLon], 10);
    
    // Ajouter les tuiles OpenStreetMap (gratuit)
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '¬© OpenStreetMap contributors',
        maxZoom: 18
    }).addTo(leafletMapInstance);
    
    // Ajouter un marqueur √† la position actuelle
    if (currentLat && currentLon) {
        addMarker(currentLat, currentLon);
    }
    
    // Gestionnaire de clic sur la carte
    leafletMapInstance.on('click', function(e) {
        const lat = e.latlng.lat;
        const lon = e.latlng.lng;
        
        // Mettre √† jour les champs de coordonn√©es
        updateCoordinates(lat, lon);
        
        // D√©placer le marqueur
        addMarker(lat, lon);
        
        console.log(`üìç Nouvelle position s√©lectionn√©e: ${lat.toFixed(4)}, ${lon.toFixed(4)}`);
    });
    
    console.log('üó∫Ô∏è Carte initialis√©e avec succ√®s');
}

// Ajouter ou d√©placer le marqueur
function addMarker(lat, lon) {
    // Supprimer le marqueur existant
    if (leafletMarker) {
        leafletMapInstance.removeLayer(leafletMarker);
    }
    
    // Cr√©er un nouveau marqueur
    leafletMarker = L.marker([lat, lon], {
        draggable: true
    }).addTo(leafletMapInstance);
    
    // Popup avec les coordonn√©es
    leafletMarker.bindPopup(`
        <b>üìç Position s√©lectionn√©e</b><br>
        Latitude: ${lat.toFixed(4)}<br>
        Longitude: ${lon.toFixed(4)}
    `).openPopup();
    
    // Gestionnaire de drag du marqueur
    leafletMarker.on('dragend', function(e) {
        const newPos = e.target.getLatLng();
        updateCoordinates(newPos.lat, newPos.lng);
        
        // Mettre √† jour le popup
        leafletMarker.bindPopup(`
            <b>üìç Position s√©lectionn√©e</b><br>
            Latitude: ${newPos.lat.toFixed(4)}<br>
            Longitude: ${newPos.lng.toFixed(4)}
        `).openPopup();
        
        console.log(`üîÑ Marqueur d√©plac√©: ${newPos.lat.toFixed(4)}, ${newPos.lng.toFixed(4)}`);
    });
}

// Mettre √† jour les champs de coordonn√©es
function updateCoordinates(lat, lon) {
    document.getElementById('latInput').value = lat.toFixed(4);
    document.getElementById('lonInput').value = lon.toFixed(4);
    
    // D√©clencher l'√©v√©nement change pour les autres fonctions
    document.getElementById('latInput').dispatchEvent(new Event('change'));
    document.getElementById('lonInput').dispatchEvent(new Event('change'));
}

// Basculer l'affichage de la carte
function toggleMap() {
    const mapContainer = document.getElementById('mapContainer');
    const toggleBtn = document.getElementById('mapToggleBtn');
    
    if (!isMapVisible) {
        // Afficher la carte
        mapContainer.style.display = 'block';
        toggleBtn.innerHTML = 'üó∫Ô∏è Fermer la Carte';
        isMapVisible = true;
        
        // Initialiser la carte si n√©cessaire
        if (!leafletMapInstance) {
            setTimeout(() => {
                initMap();
                // Redimensionner la carte apr√®s affichage
                leafletMapInstance.invalidateSize();
            }, 100);
        } else {
            // Redimensionner la carte existante
            setTimeout(() => {
                leafletMapInstance.invalidateSize();
            }, 100);
        }
        
    } else {
        // Masquer la carte
        mapContainer.style.display = 'none';
        toggleBtn.innerHTML = 'üó∫Ô∏è Ouvrir la Carte';
        isMapVisible = false;
    }
}

// Centrer la carte sur une position
function centerMapOn(lat, lon, zoom = 12) {
    if (leafletMapInstance) {
        leafletMapInstance.setView([lat, lon], zoom);
        addMarker(lat, lon);
    }
}

// G√©olocalisation am√©lior√©e
function getCurrentLocation() {
    if (!navigator.geolocation) {
        alert('‚ùå La g√©olocalisation n'est pas support√©e par votre navigateur');
        return;
    }
    
    // Afficher un indicateur de chargement
    const btn = event.target;
    const originalText = btn.innerHTML;
    btn.innerHTML = 'üîÑ Localisation...';
    btn.disabled = true;
    
    navigator.geolocation.getCurrentPosition(
        (position) => {
            const lat = position.coords.latitude;
            const lon = position.coords.longitude;
            const accuracy = position.coords.accuracy;
            
            // Mettre √† jour les coordonn√©es
            updateCoordinates(lat, lon);
            
            // Centrer la carte si elle est visible
            if (isMapVisible && leafletMapInstance) {
                centerMapOn(lat, lon, 14);
            }
            
            // Restaurer le bouton
            btn.innerHTML = originalText;
            btn.disabled = false;
            
            console.log(`üìç Position d√©tect√©e: ${lat.toFixed(4)}, ${lon.toFixed(4)} (pr√©cision: ${accuracy.toFixed(0)}m)`);
            
            // Afficher une confirmation
            alert(`‚úÖ Position d√©tect√©e avec succ√®s !\nLatitude: ${lat.toFixed(4)}\nLongitude: ${lon.toFixed(4)}\nPr√©cision: ${accuracy.toFixed(0)}m`);
        },
        (error) => {
            // Restaurer le bouton
            btn.innerHTML = originalText;
            btn.disabled = false;
            
            let errorMessage = '‚ùå Erreur de g√©olocalisation: ';
            switch (error.code) {
                case error.PERMISSION_DENIED:
                    errorMessage += 'Permission refus√©e par l\'utilisateur';
                    break;
                case error.POSITION_UNAVAILABLE:
                    errorMessage += 'Position non disponible';
                    break;
                case error.TIMEOUT:
                    errorMessage += 'D√©lai d\'attente d√©pass√©';
                    break;
                default:
                    errorMessage += 'Erreur inconnue';
                    break;
            }
            
            console.warn(errorMessage);
            alert(errorMessage);
        },
        {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 300000 // 5 minutes
        }
    );
}

// Recherche d'adresse (optionnel - n√©cessite une API de g√©ocodage)
function searchLocation() {
    const address = prompt('üîç Entrez une adresse ou nom de lieu:');
    if (!address) return;
    
    // Utilisation de l'API Nominatim (gratuite) pour le g√©ocodage
    const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}&limit=1`;
    
    fetch(url)
        .then(response => response.json())
        .then(data => {
            if (data && data.length > 0) {
                const result = data[0];
                const lat = parseFloat(result.lat);
                const lon = parseFloat(result.lon);
                
                updateCoordinates(lat, lon);
                
                if (isMapVisible && leafletMapInstance) {
                    centerMapOn(lat, lon, 12);
                }
                
                alert(`‚úÖ Lieu trouv√©: ${result.display_name}\nLatitude: ${lat.toFixed(4)}\nLongitude: ${lon.toFixed(4)}`);
            } else {
                alert('‚ùå Lieu non trouv√©. Essayez avec une adresse plus pr√©cise.');
            }
        })
        .catch(error => {
            console.error('Erreur de g√©ocodage:', error);
            alert('‚ùå Erreur lors de la recherche d\'adresse');
        });
}

// seasonal.js - Gestion du suivi saisonnier automatique
let currentSelectedDay = null;
let seasonalData = null;
let isSeasonalMode = false;
let seasonalInitialized = false;

// Configuration de la heatmap am√©lior√©e
const HEATMAP_CONFIG = {
    cellSize: 10,  // Augment√© pour une meilleure visibilit√©
    cellPadding: 1,
    monthLabels: ['Jan', 'F√©v', 'Mar', 'Avr', 'Mai', 'Jun', 'Jul', 'Ao√ª', 'Sep', 'Oct', 'Nov', 'D√©c'],
    dayLabels: ['D', 'L', 'M', 'M', 'J', 'V', 'S']
};

// Initialisation du syst√®me saisonnier
function initSeasonalSystem() {
    if (seasonalInitialized) return;
    
    if (window.debugMode) console.log('üåç Initialisation du syst√®me saisonnier...');
    
    // Initialiser les √©v√©nements
    initSeasonalEventListeners();
    
    // Cr√©er la heatmap container
    createHeatmapContainer();
    
    // V√©rifier l'√©tat initial du mode saisonnier
    updateSeasonalVisibility();
    
    seasonalInitialized = true;
    if (window.debugMode) console.log('‚úÖ Syst√®me saisonnier initialis√©');
    if (window.debugMode) console.log(`[SEASON] Syst√®me saisonnier initialis√©`);
}

// Nouvelle fonction pour g√©rer la visibilit√© des √©l√©ments saisonniers
function updateSeasonalVisibility() {
    const seasonalMode = document.getElementById('seasonalMode');
    const seasonalNavigation = document.getElementById('seasonalNavigation');
    const heatmapContainer = document.getElementById('seasonalHeatmap');
    const toolsContainer = document.getElementById('seasonalTools');
    if (!seasonalMode) return;
    
    const isEnabled = seasonalMode.checked;

    // Afficher/masquer la navigation saisonni√®re
    if (seasonalNavigation) seasonalNavigation.style.display = isEnabled ? 'block' : 'none';
    if (heatmapContainer) heatmapContainer.style.display = isEnabled ? 'block' : 'none';
    if (toolsContainer) toolsContainer.style.display = isEnabled ? 'block' : 'none';

    // Si le mode saisonnier est activ√©
    if (isEnabled) {
        // V√©rifie s'il y a d√©j√† des donn√©es r√©elles assez volumineuses
        let hasValidSeasonalData =
            Array.isArray(seasonalData) &&
            seasonalData.length === 366 &&
            seasonalData.every(day => Array.isArray(day) && day.length === 24);

        if (!hasValidSeasonalData) {
            // Donn√©es r√©elles manquantes : charger d√©mo
            if (window.debugMode)
                console.warn("[SEASON] Donn√©es saisonni√®res absentes ou incompl√®tes, chargement des donn√©es de d√©monstration.");
            createDemoSeasonalData();
        }

        // S√©lection automatique du jour actuel
        const today = new Date();
        const startOfYear = new Date(today.getFullYear(), 0, 1);
        const dayOfYear = Math.floor((today - startOfYear) / (1000 * 60 * 60 * 24));
        setTimeout(() => {
            selectDay(dayOfYear);
            if (window.debugMode)
                console.log(`[SEASON] Jour actuel s√©lectionn√© automatiquement: ${dayOfYear + 1} (${today.toLocaleDateString('fr-FR')})`);
        }, 500);
    } else {
        // R√©initialiser la s√©lection quand le mode est d√©sactiv√©
        currentSelectedDay = null;
    }

    if (window.debugMode)
        console.log(`üåç Mode saisonnier ${isEnabled ? 'activ√©' : 'd√©sactiv√©'}`);
}


// Initialisation des donn√©es saisonni√®res (processus long)
async function initializeSeasonalData() {
    const initButton = document.getElementById('initSeasonalBtn');
    const progressDiv = document.getElementById('seasonalProgress');
    const progressBar = document.getElementById('seasonalProgressBar');
    const progressText = document.getElementById('seasonalProgressText');

    if (!initButton || !progressDiv) return;

    const lat = document.getElementById('latInput').value;
    const lon = document.getElementById('lonInput').value;
    if (!lat || !lon) {
        alert('‚ö†Ô∏è Veuillez configurer les coordonn√©es GPS avant d\'initialiser les donn√©es saisonni√®res');
        return;
    }

    const confirmed = confirm(
        'üåç Initialisation des donn√©es saisonni√®res\n\n' +
        'Cette op√©ration va t√©l√©charger 4 ann√©es de donn√©es m√©t√©orologiques historiques.\n' +
        'Cela peut prendre plusieurs minutes.\n\n' +
        'Voulez-vous continuer ?'
    );
    if (!confirmed) return;

    try {
        initButton.disabled = true;
        initButton.textContent = '‚è≥ Initialisation en cours...';
        progressDiv.style.display = 'block';

        // D√©marrer l'initialisation sur le backend
        const startResponse = await fetch('/initSeasonalData', { method: 'POST' });
        if (!startResponse.ok) {
            throw new Error('Impossible de d√©marrer l\'initialisation sur le serveur.');
        }

        // Interroger le statut p√©riodiquement
        const intervalId = setInterval(async () => {
            try {
                const statusResponse = await fetch('/initStatus');
                const status = await statusResponse.json();

                progressBar.style.width = `${status.progress}%`;
                progressText.textContent = status.status;

                if (!status.running) {
                    clearInterval(intervalId);
                    initButton.disabled = false;
                    initButton.textContent = 'üì• Initialiser les donn√©es saisonni√®res';
                    progressDiv.style.display = 'none';
                    if (status.progress === 100) {
                        showNotification('‚úÖ Donn√©es saisonni√®res initialis√©es avec succ√®s !', 'success');
                        // Mettre √† jour la heatmap
                        const averages = await fetch('/getYearlyAverages').then(res => res.json());
                        seasonalData = averages; // Assigner les donn√©es r√©elles √† seasonalData
                        createHeatmap(seasonalData);
                    } else {
                        showNotification('‚ùå Erreur ou arr√™t de l\'initialisation.', 'error');
                    }
                }
            } catch (e) {
                clearInterval(intervalId);
                throw e;
            }
        }, 2000);

    } catch (error) {
        console.error('‚ùå Erreur lors de l\'initialisation:', error);
        showNotification('‚ùå Erreur lors de l\'initialisation: ' + error.message, 'error');
        initButton.disabled = false;
        initButton.textContent = 'üì• Initialiser les donn√©es saisonni√®res';
        progressDiv.style.display = 'none';
    }
}

// Simulation du processus d'initialisation
async function simulateInitialization() {
    const progressBar = document.getElementById('seasonalProgressBar');
    const progressText = document.getElementById('seasonalProgressText');
    
    if (!progressBar || !progressText) return;
    
    const steps = [
        { progress: 10, text: 'Connexion √† l\'API m√©t√©o...' },
        { progress: 25, text: 'T√©l√©chargement ann√©e 2021...' },
        { progress: 40, text: 'T√©l√©chargement ann√©e 2022...' },
        { progress: 55, text: 'T√©l√©chargement ann√©e 2023...' },
        { progress: 70, text: 'T√©l√©chargement ann√©e 2024...' },
        { progress: 85, text: 'Calcul des moyennes...' },
        { progress: 95, text: 'Sauvegarde des donn√©es...' },
        { progress: 100, text: 'Initialisation termin√©e !' }
    ];
    
    for (const step of steps) {
        progressBar.style.width = `${step.progress}%`;
        progressText.textContent = step.text;
        await new Promise(resolve => setTimeout(resolve, 800));
    }
}

// Cr√©ation de donn√©es de d√©monstration - CORRIG√âE POUR 2025
function createDemoSeasonalData() {
    // G√©n√©rer 366 jours de donn√©es de temp√©rature (24 heures par jour) pour 2025
    seasonalData = [];
    
    for (let day = 0; day < 366; day++) {
        const dayTemps = [];
        
        // Simuler une variation saisonni√®re
        const seasonalBase = 20 + 10 * Math.sin((day / 366) * 2 * Math.PI - Math.PI/2);
        
        for (let hour = 0; hour < 24; hour++) {
            // Variation journali√®re
            const dailyVariation = 5 * Math.sin((hour / 24) * 2 * Math.PI - Math.PI/2);
            
            // Ajouter un peu de bruit
            const noise = (Math.random() - 0.5) * 2;
            
            const temp = seasonalBase + dailyVariation + noise;
            dayTemps.push(Math.round(temp * 10) / 10);
        }
        
        seasonalData.push(dayTemps);
    }
    
    // Afficher la heatmap si le mode saisonnier est activ√©
    const seasonalMode = document.getElementById('seasonalMode');
    if (seasonalMode && seasonalMode.checked) {
        createHeatmap(seasonalData);
        document.getElementById('seasonalHeatmap').style.display = 'block';
    }
    if (window.debugMode) console.log(`‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è[SEASON] create DEMO Seasonal Data initialis√©`);
}

// Cr√©ation de la heatmap calendaire - Largeur compl√®te avec tooltip corrig√©
function createHeatmap(data) {
    const container = document.getElementById('heatmapCanvas');
    if (!container) return;
    
    // Nettoyer le conteneur
    container.innerHTML = '';
    
    // Cr√©er le canvas pour la heatmap - Largeur compl√®te
    const canvas = document.createElement('canvas');
    const containerWidth = container.offsetWidth || 1200;
    canvas.width = Math.max(containerWidth - 40, 1000);  // Largeur adaptative
    canvas.height = 180;  // Hauteur optimis√©e
    canvas.style.width = '100%';
    canvas.style.height = 'auto';
    canvas.style.cursor = 'pointer';
    canvas.style.display = 'block';
    
    const ctx = canvas.getContext('2d');
    
    // Dessiner la heatmap
    drawYearlyHeatmap(ctx, data, canvas.width, canvas.height);
    
    // Ajouter les √©v√©nements de clic et survol
    canvas.addEventListener('click', (event) => {
        const rect = canvas.getBoundingClientRect();
        const x = (event.clientX - rect.left) * (canvas.width / rect.width);
        const y = (event.clientY - rect.top) * (canvas.height / rect.height);
        
        const dayIndex = getDayFromCoordinates(x, y, canvas.width, canvas.height);
        if (dayIndex >= 0 && dayIndex < 366) {
            selectDay(dayIndex);
        }
    });
    
    // ‚úÖ TOOLTIP CORRIG√â - Ajouter le tooltip au survol
    canvas.addEventListener('mousemove', (event) => {
        const rect = canvas.getBoundingClientRect();
        const x = (event.clientX - rect.left) * (canvas.width / rect.width);
        const y = (event.clientY - rect.top) * (canvas.height / rect.height);
        
        const dayIndex = getDayFromCoordinates(x, y, canvas.width, canvas.height);
        if (dayIndex >= 0 && dayIndex < 366 && seasonalData && seasonalData[dayIndex]) {
            showTooltip(event, dayIndex);
        } else {
            hideTooltip();
        }
    });
    
    canvas.addEventListener('mouseleave', hideTooltip);
    
    container.appendChild(canvas);
    if (window.debugMode) console.log(`[SEASON] Cr√©ation heatmap avec ${Array.isArray(seasonalData) ? seasonalData.length : 0} jours`);
}

// ‚úÖ TOOLTIP ENTI√àREMENT CORRIG√â - Affichage du tooltip am√©lior√© avec date 2025
function showTooltip(event, dayIndex) {
    let tooltip = document.getElementById('heatmapTooltip');
    if (!tooltip) {
        tooltip = document.createElement('div');
        tooltip.id = 'heatmapTooltip';
        tooltip.className = 'fixed bg-gray-800 text-white p-3 rounded-lg shadow-lg text-sm z-50 pointer-events-none border border-gray-600';
        tooltip.style.maxWidth = '250px';
        document.body.appendChild(tooltip);
    }
    
    // ‚úÖ Calculer la date correctement pour 2025 - CORRECTION DU D√âCALAGE
    const currentYear = new Date().getFullYear(); // 2025
    const date = new Date(currentYear, 0, dayIndex + 1); // +1 car dayIndex commence √† 0
    const dateStr = date.toLocaleDateString('fr-FR', { 
        weekday: 'long', 
        year: 'numeric', 
        month: 'long', 
        day: 'numeric' 
    });
    
    // ‚úÖ Calculer la temp√©rature moyenne du jour depuis seasonalData
    let avgTemp = 22;
    let minTemp = 20;
    let maxTemp = 25;
    
    if (seasonalData && seasonalData[dayIndex] && Array.isArray(seasonalData[dayIndex])) {
        const dayTemps = seasonalData[dayIndex];
        if (dayTemps.length === 24) {
            const validTemps = dayTemps.filter(temp => typeof temp === 'number' && !isNaN(temp));
            if (validTemps.length > 0) {
                avgTemp = validTemps.reduce((sum, temp) => sum + temp, 0) / validTemps.length;
                minTemp = Math.min(...validTemps);
                maxTemp = Math.max(...validTemps);
            }
        }
    }
    
    tooltip.innerHTML = `
        <div class="font-semibold text-blue-300">${dateStr}</div>
        <div class="text-gray-300">Jour ${dayIndex + 1} de l'ann√©e</div>
        <div class="mt-2">
            <div>üå°Ô∏è Moyenne: <span class="font-semibold">${avgTemp.toFixed(1)}¬∞C</span></div>
            <div>‚ùÑÔ∏è Min: ${minTemp.toFixed(1)}¬∞C | üî• Max: ${maxTemp.toFixed(1)}¬∞C</div>
        </div>
        <div class="text-xs text-gray-400 mt-2 border-t border-gray-600 pt-2">
            üñ±Ô∏è Cliquez pour √©diter cette journ√©e
        </div>
    `;
    
    // ‚úÖ Positionner le tooltip de mani√®re intelligente
    const tooltipRect = tooltip.getBoundingClientRect();
    let left = event.pageX + 15;
    let top = event.pageY - 10;
    
    // Ajuster si le tooltip d√©passe de l'√©cran
    if (left + 250 > window.innerWidth) {  // Utiliser la largeur max du tooltip
        left = event.pageX - 250 - 15;
    }
    if (top + 120 > window.innerHeight) {  // Estimation de la hauteur du tooltip
        top = event.pageY - 120 - 10;
    }
    
    tooltip.style.left = `${left}px`;
    tooltip.style.top = `${top}px`;
    tooltip.style.display = 'block';
    tooltip.style.opacity = '1';
}

// Masquer le tooltip
function hideTooltip() {
    const tooltip = document.getElementById('heatmapTooltip');
    if (tooltip) {
        tooltip.style.display = 'none';
        tooltip.style.opacity = '0';
    }
}

// Dessin de la heatmap annuelle am√©lior√© - Largeur compl√®te
function drawYearlyHeatmap(ctx, data, width, height) {
    const { cellSize, cellPadding } = HEATMAP_CONFIG;
    const startX = 80;  // Marge pour les labels
    const startY = 30;
    const availableWidth = width - startX - 20;
    const monthWidth = availableWidth / 12;  // Largeur adaptative par mois
    const cellsPerWeek = 7;
    const weeksPerMonth = 6;  // Augment√© pour plus d'espace
    
    // Calculer les temp√©ratures min/max pour la colorisation
    const allTemps = data.flat().filter(temp => typeof temp === 'number' && !isNaN(temp));
    const minTemp = Math.min(...allTemps);
    const maxTemp = Math.max(...allTemps);
    
    // Dessiner les labels des mois
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 14px Arial';
    ctx.textAlign = 'center';
    for (let month = 0; month < 12; month++) {
        const x = startX + month * monthWidth + monthWidth / 2;
        ctx.fillText(HEATMAP_CONFIG.monthLabels[month], x, 20);
    }
    
    // Dessiner les labels des jours de la semaine
    ctx.font = '12px Arial';
    ctx.textAlign = 'right';
    for (let day = 0; day < 7; day++) {
        const y = startY + day * (cellSize + cellPadding) + cellSize / 2 + 4;
        ctx.fillText(HEATMAP_CONFIG.dayLabels[day], startX - 10, y);
    }
    
    // ‚úÖ CORRECTION MAJEURE DU CALCUL DES POSITIONS - Dessiner les cellules pour chaque jour
    const currentYear = new Date().getFullYear(); // 2025
    data.forEach((dayTemps, dayIndex) => {
        if (!Array.isArray(dayTemps) || dayTemps.length === 0) return;
        
        const validTemps = dayTemps.filter(temp => typeof temp === 'number' && !isNaN(temp));
        if (validTemps.length === 0) return;
        
        const avgTemp = validTemps.reduce((sum, temp) => sum + temp, 0) / validTemps.length;
        
        // ‚úÖ Calculer la position dans la grille - ENTI√àREMENT CORRIG√â
        const date = new Date(currentYear, 0, dayIndex + 1); // +1 car dayIndex commence √† 0
        const month = date.getMonth();
        const dayOfMonth = date.getDate();
        const weekday = date.getDay(); // 0 = dimanche, 1 = lundi, etc.
        
        // ‚úÖ Calculer la semaine du mois de mani√®re plus pr√©cise
        const firstDayOfMonth = new Date(currentYear, month, 1);
        const firstWeekday = firstDayOfMonth.getDay();
        
        // Calculer dans quelle semaine du mois se trouve ce jour
        const weekOfMonth = Math.floor((dayOfMonth + firstWeekday - 1) / 7);
        
        // ‚úÖ V√©rifier que la position est valide
        if (weekOfMonth >= 6) return; // √âviter les d√©bordements
        
        const cellWidth = Math.min(cellSize, (monthWidth - cellPadding * 6) / 5);
        const x = startX + month * monthWidth + weekOfMonth * (cellWidth + cellPadding);
        const y = startY + weekday * (cellSize + cellPadding);
        
        // Couleur bas√©e sur la temp√©rature
        let intensity;
        if (maxTemp - minTemp === 0) {
            intensity = 0.5; // Toutes les temp√©ratures sont identiques, utiliser une couleur m√©diane
        } else {
            intensity = (avgTemp - minTemp) / (maxTemp - minTemp);
        }
        const color = getTemperatureColor(intensity);
        
        ctx.fillStyle = color;
        ctx.fillRect(x, y, cellWidth, cellSize);
        
        // ‚úÖ Bordure pour le jour s√©lectionn√© - CORRIG√âE
        if (dayIndex === currentSelectedDay) {
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
            ctx.strokeRect(x - 1, y - 1, cellWidth + 2, cellSize + 2);
        }
    });
    
    // Ajouter une l√©gende de couleurs
    drawColorLegend(ctx, width, height, minTemp, maxTemp);
}

// Dessiner la l√©gende des couleurs am√©lior√©e
function drawColorLegend(ctx, width, height, minTemp, maxTemp) {
    const legendWidth = 300;
    const legendHeight = 15;
    const legendX = (width - legendWidth) / 2;  // Centr√©
    const legendY = height - 40;
    
    // Dessiner le gradient
    const gradient = ctx.createLinearGradient(legendX, 0, legendX + legendWidth, 0);
    gradient.addColorStop(0, getTemperatureColor(0));
    gradient.addColorStop(0.2, getTemperatureColor(0.2));
    gradient.addColorStop(0.4, getTemperatureColor(0.4));
    gradient.addColorStop(0.6, getTemperatureColor(0.6));
    gradient.addColorStop(0.8, getTemperatureColor(0.8));
    gradient.addColorStop(1, getTemperatureColor(1));
    
    ctx.fillStyle = gradient;
    ctx.fillRect(legendX, legendY, legendWidth, legendHeight);
    
    // Bordure de la l√©gende
    ctx.strokeStyle = '#666666';
    ctx.lineWidth = 1;
    ctx.strokeRect(legendX, legendY, legendWidth, legendHeight);
    
    // Labels de la l√©gende
    ctx.fillStyle = '#ffffff';
    ctx.font = '12px Arial';
    ctx.textAlign = 'left';
    ctx.fillText(`${minTemp.toFixed(1)}¬∞C`, legendX, legendY + legendHeight + 20);
    ctx.textAlign = 'center';
    ctx.fillText(`${((minTemp + maxTemp) / 2).toFixed(1)}¬∞C`, legendX + legendWidth / 2, legendY + legendHeight + 20);
    ctx.textAlign = 'right';
    ctx.fillText(`${maxTemp.toFixed(1)}¬∞C`, legendX + legendWidth, legendY + legendHeight + 20);
}

// Obtenir la couleur selon la temp√©rature (am√©lior√©)
function getTemperatureColor(intensity) {
    // Gradient plus naturel du bleu au rouge
    const colors = [
        [0, 100, 255],    // Bleu froid
        [0, 200, 200],    // Cyan
        [100, 255, 100],  // Vert
        [255, 255, 0],    // Jaune
        [255, 150, 0],    // Orange
        [255, 0, 0]       // Rouge chaud
    ];
    
    const scaledIntensity = Math.max(0, Math.min(1, intensity));
    const colorIndex = scaledIntensity * (colors.length - 1);
    const lowerIndex = Math.floor(colorIndex);
    const upperIndex = Math.ceil(colorIndex);
    const ratio = colorIndex - lowerIndex;
    
    if (lowerIndex === upperIndex) {
        const [r, g, b] = colors[lowerIndex];
        return `rgb(${r}, ${g}, ${b})`;
    }
    
    const [r1, g1, b1] = colors[lowerIndex];
    const [r2, g2, b2] = colors[upperIndex];
    
    const r = Math.round(r1 + (r2 - r1) * ratio);
    const g = Math.round(g1 + (g2 - g1) * ratio);
    const b = Math.round(b1 + (b2 - b1) * ratio);
    
    return `rgb(${r}, ${g}, ${b})`;
}

// ‚úÖ CORRECTION MAJEURE - Obtenir le jour √† partir des coordonn√©es de clic - ENTI√àREMENT REVU
function getDayFromCoordinates(x, y, canvasWidth, canvasHeight) {
    const { cellSize, cellPadding } = HEATMAP_CONFIG;
    const startX = 80;
    const startY = 30;
    const availableWidth = canvasWidth - startX - 20;
    const monthWidth = availableWidth / 12;
    
    // ‚úÖ Calculer le mois
    const month = Math.floor((x - startX) / monthWidth);
    if (month < 0 || month >= 12) return -1;
    
    // ‚úÖ Calculer la semaine dans le mois
    const cellWidth = Math.min(cellSize, (monthWidth - cellPadding * 6) / 5);
    const weekInMonth = Math.floor((x - startX - month * monthWidth) / (cellWidth + cellPadding));
    if (weekInMonth < 0 || weekInMonth >= 6) return -1;
    
    // ‚úÖ Calculer le jour de la semaine
    const weekday = Math.floor((y - startY) / (cellSize + cellPadding));
    if (weekday < 0 || weekday >= 7) return -1;
    
    // ‚úÖ NOUVELLE M√âTHODE : Parcourir tous les jours pour trouver celui qui correspond
    const currentYear = new Date().getFullYear(); // 2025
    
    // Parcourir tous les jours de l'ann√©e pour trouver celui qui correspond aux coordonn√©es
    for (let dayIndex = 0; dayIndex < 366; dayIndex++) {
        const date = new Date(currentYear, 0, dayIndex + 1);
        
        // V√©rifier si cette date correspond au mois cliqu√©
        if (date.getMonth() !== month) continue;
        
        const dayOfMonth = date.getDate();
        const dayWeekday = date.getDay();
        
        // Calculer la position de ce jour
        const firstDayOfMonth = new Date(currentYear, month, 1);
        const firstWeekday = firstDayOfMonth.getDay();
        const dayWeekOfMonth = Math.floor((dayOfMonth + firstWeekday - 1) / 7);
        
        // V√©rifier si ce jour correspond aux coordonn√©es cliqu√©es
        if (dayWeekOfMonth === weekInMonth && dayWeekday === weekday) {
            return dayIndex;
        }
    }
    
    return -1; // Aucun jour trouv√©
}

// S√©lection d'un jour pour √©dition
async function selectDay(dayIndex) {
    if (window.debugMode) console.log(`[DEBUG] S√©lection du jour: ${dayIndex}`);
    currentSelectedDay = dayIndex;
    
    // Mettre √† jour la heatmap pour montrer la s√©lection
    if (seasonalData) {
        createHeatmap(seasonalData);
    }
    
    // Charger les donn√©es du jour s√©lectionn√© depuis le backend
    try {
        const response = await fetch(`/getDayData?day=${dayIndex}`);
        if (!response.ok) {
            throw new Error("Impossible de charger les donn√©es du jour");
        }
        const dayTemperatures = await response.json();
        if (window.debugMode) console.log(`[SEASON] Donn√©es du jour ${dayIndex} re√ßues:`, dayTemperatures);

        // Mettre √† jour l'√©diteur de courbe avec les donn√©es du jour
        if (typeof window.temperatureData !== 'undefined') {
            window.temperatureData = [...dayTemperatures];
            if (typeof window.updateChartAndGrid === 'function') {
                window.updateChartAndGrid();
                if (window.debugMode) console.log("[SEASON] Graphique de configuration mis √† jour.");
            }
        }
    } catch (error) {
        console.error(`‚ùå Erreur lors du chargement du jour ${dayIndex}:`, error);
        showNotification(error.message, 'error');
    }
    
    // Afficher les contr√¥les de navigation
    showDayNavigationControls(dayIndex);
    if (window.debugMode) console.log(`[SEASON] Jour s√©lectionn√© : ${dayIndex} (${new Date(new Date().getFullYear(),0,dayIndex+1).toLocaleDateString()})`);
}

// Chargement des donn√©es d'un jour sp√©cifique
async function loadDayData(dayIndex) {
    try {
        // Utiliser les donn√©es de d√©monstration
        if (seasonalData && seasonalData[dayIndex]) {
            const dayData = { temperatures: seasonalData[dayIndex] };
            
            // Mettre √† jour l'√©diteur de courbe avec les donn√©es du jour
            if (typeof window.temperatureData !== 'undefined') {
                window.temperatureData = [...dayData.temperatures];
                
                // Mettre √† jour le graphique principal si disponible
                if (typeof window.updateChartAndGrid === 'function') {
                    window.updateChartAndGrid();
                }
            }
            
            return dayData;
        }
        
        return null;
        
    } catch (error) {
        console.error(`‚ùå Erreur lors du chargement du jour ${dayIndex}:`, error);
        return null;
    }
}

// Affichage des contr√¥les de navigation pour le jour s√©lectionn√© - CORRIG√â POUR 2025
function showDayNavigationControls(dayIndex) {
    const dayInfo = document.getElementById('selectedDayInfo');
    const navigationControls = document.getElementById('dayNavigationControls');
    
    if (!dayInfo || !navigationControls) return;
    
    // ‚úÖ Calculer la date pour 2025 - CORRECTION DU D√âCALAGE
    const currentYear = new Date().getFullYear(); // 2025
    const date = new Date(currentYear, 0, dayIndex + 1); // +1 car dayIndex commence √† 0
    const dateStr = date.toLocaleDateString('fr-FR', { 
        weekday: 'long', 
        year: 'numeric', 
        month: 'long', 
        day: 'numeric' 
    });
    
    dayInfo.innerHTML = `
        <div class="font-semibold text-white">üìÖ √âdition du ${dateStr}</div>
        <div class="text-sm text-gray-400">
            Jour ${dayIndex + 1} de l'ann√©e ‚Ä¢ Modifiez la courbe ci-dessus en cliquant et glissant
        </div>
    `;
    
    // Afficher les contr√¥les de navigation
    navigationControls.style.display = 'flex';
    
    // Faire d√©filer vers la courbe d'√©dition
    const chartContainer = document.getElementById('temperatureChart');
    if (chartContainer) {
        chartContainer.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
}

// Sauvegarde des modifications d'un jour
async function saveDayModifications() {
    if (currentSelectedDay === null) {
        alert('‚ùå Aucun jour s√©lectionn√©');
        return;
    }
    
    try {
        // R√©cup√©rer les donn√©es de temp√©rature actuelles
        const temperatures = window.temperatureData || [];
        
        if (temperatures.length !== 24) {
            throw new Error('Donn√©es de temp√©rature invalides');
        }

        // Envoyer les donn√©es au backend
        const response = await fetch(`/saveDayData?day=${currentSelectedDay}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(temperatures)
        });

        if (!response.ok) {
            throw new Error("La sauvegarde sur le serveur a √©chou√©");
        }
        
        // Mettre √† jour les donn√©es locales
        if (seasonalData && seasonalData[currentSelectedDay]) {
            seasonalData[currentSelectedDay] = [...temperatures];
        }
        
        // Recr√©er la heatmap
        createHeatmap(seasonalData);
        
        // Afficher la confirmation
        showNotification('‚úÖ Modifications sauvegard√©es pour ce jour', 'success');
        if (window.debugMode) console.log(`[SEASON] Envoi de la courbe 24h pour le jour ${currentSelectedDay}`, window.temperatureData);

    } catch (error) {
        console.error('‚ùå Erreur lors de la sauvegarde:', error);
        showNotification('‚ùå Erreur lors de la sauvegarde: ' + error.message, 'error');
    }
}

// Navigation entre les jours
function navigateDay(direction) {
    if (currentSelectedDay === null) return;
    
    const newDay = currentSelectedDay + direction;
    if (newDay >= 0 && newDay < 366) {
        selectDay(newDay);
    }
}

// Fermeture de l'√©diteur de jour
function closeDayEditor() {
    currentSelectedDay = null;
    
    // Masquer les contr√¥les de navigation
    const navigationControls = document.getElementById('dayNavigationControls');
    const dayInfo = document.getElementById('selectedDayInfo');
    
    if (navigationControls) {
        navigationControls.style.display = 'none';
    }
    
    if (dayInfo) {
        dayInfo.innerHTML = `
            <div class="font-semibold">üìÖ Mode Saisonnier Activ√©</div>
            <div class="text-sm text-gray-400">S√©lectionnez un jour dans le calendrier ci-dessous pour l'√©diter</div>
        `;
    }
    
    // Recr√©er la heatmap sans s√©lection
    if (seasonalData) {
        createHeatmap(seasonalData);
    }
    
    // Nettoyer le tooltip
    hideTooltip();
}

// Outils de modification de masse
async function applyMassModification(type, params) {
    try {
        // Pour l'instant, simuler les modifications
        showNotification('‚úÖ Modification de masse appliqu√©e (simulation)', 'success');
        
    } catch (error) {
        console.error('‚ùå Erreur lors de la modification de masse:', error);
        showNotification('‚ùå Erreur: ' + error.message, 'error');
    }
}

// Plafonnement des temp√©ratures pour un mois
function capTemperaturesForMonth() {
    const month = prompt('Mois (1-12):');
    const maxTemp = prompt('Temp√©rature maximum (¬∞C):');
    const minTemp = prompt('Temp√©rature minimum (¬∞C):');
    
    if (month && maxTemp && minTemp) {
        applyMassModification('cap_month', {
            month: parseInt(month),
            maxTemp: parseFloat(maxTemp),
            minTemp: parseFloat(minTemp)
        });
    }
}

// Lissage des courbes pour un mois
function smoothCurvesForMonth() {
    const month = prompt('Mois √† lisser (1-12):');
    
    if (month) {
        applyMassModification('smooth_month', {
            month: parseInt(month)
        });
    }
}

// Copier/coller de courbes
function copyDayToMonth() {
    if (currentSelectedDay === null) {
        alert('‚ùå Veuillez d\'abord s√©lectionner un jour √† copier');
        return;
    }
    
    const month = prompt('Mois de destination (1-12):');
    
    if (month) {
        applyMassModification('copy_day_to_month', {
            sourceDay: currentSelectedDay,
            targetMonth: parseInt(month)
        });
    }
}

// Initialisation des √©v√©nements
function initSeasonalEventListeners() {
    // Bouton d'initialisation
    const initBtn = document.getElementById('initSeasonalBtn');
    if (initBtn) {
        initBtn.addEventListener('click', initializeSeasonalData);
    }
    
    // Boutons de navigation
    const prevBtn = document.getElementById('prevDayBtn');
    const nextBtn = document.getElementById('nextDayBtn');
    
    if (prevBtn) prevBtn.addEventListener('click', () => navigateDay(-1));
    if (nextBtn) nextBtn.addEventListener('click', () => navigateDay(1));
    
    // Bouton de sauvegarde
    const saveBtn = document.getElementById('saveDayBtn');
    if (saveBtn) {
        saveBtn.addEventListener('click', saveDayModifications);
    }
    
    // Outils de modification de masse
    const capBtn = document.getElementById('capTempsBtn');
    const smoothBtn = document.getElementById('smoothMonthBtn');
    const copyBtn = document.getElementById('copyDayBtn');
    
    if (capBtn) capBtn.addEventListener('click', capTemperaturesForMonth);
    if (smoothBtn) smoothBtn.addEventListener('click', smoothCurvesForMonth);
    if (copyBtn) copyBtn.addEventListener('click', copyDayToMonth);
}

// Cr√©ation du conteneur de heatmap
function createHeatmapContainer() {
    const container = document.getElementById('heatmapCanvas');
    if (!container) {
        console.warn('‚ö†Ô∏è Conteneur heatmapCanvas non trouv√©');
        return;
    }
    
    // Ajouter les styles n√©cessaires pour largeur compl√®te
    container.style.border = '1px solid #374151';
    container.style.borderRadius = '8px';
    container.style.backgroundColor = '#1f2937';
    container.style.padding = '15px';
    container.style.width = '100%';
    container.style.boxSizing = 'border-box';
}

// Fonction utilitaire pour les notifications
function showNotification(message, type = 'info') {
    // Cr√©er une notification temporaire
    const notification = document.createElement('div');
    notification.className = `fixed top-4 right-4 p-4 rounded-lg shadow-lg z-50 ${
        type === 'success' ? 'bg-green-600' : 
        type === 'error' ? 'bg-red-600' : 'bg-blue-600'
    } text-white`;
    notification.textContent = message;
    
    document.body.appendChild(notification);
    
    // Supprimer apr√®s 3 secondes
    setTimeout(() => {
        if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
        }
    }, 3000);
}

// Export des fonctions principales
window.initSeasonalSystem = initSeasonalSystem;
window.updateSeasonalVisibility = updateSeasonalVisibility;
window.selectDay = selectDay;
window.saveDayModifications = saveDayModifications;
window.navigateDay = navigateDay;
window.closeDayEditor = closeDayEditor;
window.initializeSeasonalData = initializeSeasonalData;


// surveillance.js - Graphiques de surveillance en temps r√©el

// Fonction pour calculer la moyenne mobile
function calculateMovingAverage(data, windowSize) {
    if (!data || data.length === 0) return [];
    
    const result = [];
    for (let i = 0; i < data.length; i++) {
        const start = Math.max(0, i - windowSize + 1);
        const window = data.slice(start, i + 1);
        const average = window.reduce((sum, val) => sum + val, 0) / window.length;
        result.push(average);
    }
    return result;
}

// Configuration des graphiques
const chartConfig = {
    responsive: true,
    maintainAspectRatio: false,
    interaction: {
        intersect: false,
        mode: 'index'
    },
    plugins: {
        legend: {
            labels: {
                color: '#ffffff',
                font: { size: 12 }
            }
        },
        tooltip: {
            backgroundColor: 'rgba(0, 0, 0, 0.8)',
            titleColor: '#ffffff',
            bodyColor: '#ffffff',
            borderColor: '#374151',
            borderWidth: 1
        }
    },
    scales: {
        x: {
            grid: { color: 'rgba(255, 255, 255, 0.1)' },
            ticks: { 
                color: '#ffffff',
                maxTicksLimit: 10
            }
        },
        y: {
            grid: { color: 'rgba(255, 255, 255, 0.1)' },
            ticks: { color: '#ffffff' }
        }
    },
    elements: {
        line: {
            tension: 0.3
        },
        point: {
            radius: 2,
            hoverRadius: 6
        }
    }
};

// Initialisation des graphiques de surveillance
function initCharts() {
    console.log('üìä Initialisation des graphiques de surveillance...');
    
    // Graphique de temp√©rature
    const tempCtx = document.getElementById('tempChart');
    if (tempCtx) {
        tempChart = new Chart(tempCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [
                    {
                        label: 'Temp√©rature (¬∞C)',
                        data: [],
                        borderColor: '#f59e0b',
                        backgroundColor: 'rgba(245, 158, 11, 0.1)',
                        borderWidth: 2,
                        fill: true
                    },
                    {
                        label: 'Moyenne mobile 24h',
                        data: [],
                        borderColor: '#ef4444',
                        backgroundColor: 'transparent',
                        borderWidth: 1,
                        borderDash: [5, 5],
                        fill: false,
                        pointRadius: 0
                    }
                ]
            },
            options: {
                ...chartConfig,
                scales: {
                    ...chartConfig.scales,
                    y: {
                        ...chartConfig.scales.y,
                        title: {
                            display: true,
                            text: 'Temp√©rature (¬∞C)',
                            color: '#ffffff'
                        }
                    }
                }
            }
        });
    }
    
    // Graphique d'humidit√©
    const humCtx = document.getElementById('humidityChart');
    if (humCtx) {
        humidityChart = new Chart(humCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [
                    {
                        label: 'Humidit√© (%)',
                        data: [],
                        borderColor: '#3b82f6',
                        backgroundColor: 'rgba(59, 130, 246, 0.1)',
                        borderWidth: 2,
                        fill: true
                    },
                    {
                        label: 'Moyenne mobile 24h',
                        data: [],
                        borderColor: '#06b6d4',
                        backgroundColor: 'transparent',
                        borderWidth: 1,
                        borderDash: [5, 5],
                        fill: false,
                        pointRadius: 0
                    }
                ]
            },
            options: {
                ...chartConfig,
                scales: {
                    ...chartConfig.scales,
                    y: {
                        ...chartConfig.scales.y,
                        title: {
                            display: true,
                            text: 'Humidit√© (%)',
                            color: '#ffffff'
                        },
                        min: 0,
                        max: 100
                    }
                }
            }
        });
    }
    
    console.log('‚úÖ Graphiques de surveillance initialis√©s');
}

// Export des fonctions pour utilisation globale
window.initCharts = initCharts;
window.calculateMovingAverage = calculateMovingAverage;


<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/css/style.css">
    <title>Contr√¥leur Vivarium</title>
    <link rel="icon" type="image/x-icon" href="/images/favicon.ico">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectrum/1.8.0/spectrum.min.css">
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css">

    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
</head>
<body>
    <div class="container mx-auto px-4 py-6 max-w-7xl">
        <!-- Header -->
        <div class="text-center mb-8 fade-in">
            <h1 class="text-4xl font-bold mb-2">
                <i class="fas text-orange-500 mr-3"></i>
                Contr√¥leur Vivarium 
            </h1>
        </div>

        <!-- Navigation Tabs -->
        <div class="flex justify-center mb-8">
            <div class="bg-gray-800 rounded-lg p-1 inline-flex">
                <button id="tabDashboard" class="tab-button px-6 py-3 rounded-md tab-active transition-all duration-300">
                    <i class="fas fa-chart-line mr-2"></i>Surveillance
                </button>
                <button id="tabConfig" class="tab-button px-6 py-3 rounded-md tab-inactive transition-all duration-300">
                    <i class="fas fa-cog mr-2"></i>Configuration
                </button>
            </div>
        </div>

        <!-- Dashboard Tab -->
        <div id="dashboardContent" class="tab-content">
            <!-- Status Cards -->
            <div class="grid grid-cols-1 md:grid-cols-4 gap-6 mb-8">
                <div class="metric-card fade-in">
                    <div class="metric-label">Temp√©rature</div>
                    <div id="temperature" class="metric-value">--¬∞C</div>
                    <div class="text-sm text-gray-400">
                        Min: <span id="minTemperature">--¬∞C</span> | Max: <span id="maxTemperature">--¬∞C</span>
                    </div>
                    <div class="text-sm text-gray-400">
                       Moyenne 24h: <span id="movingAverageTemp">--¬∞C</span>
                    </div>
                </div>
                
                <div class="metric-card fade-in">
                    <div class="metric-label">Humidit√©</div>
                    <div id="humidity" class="metric-value">--%</div>
                    <div class="text-sm text-gray-400">
                        Min: <span id="minHumidite">--%</span> | Max: <span id="maxHumidite">--%</span>
                    </div>
                    <div class="text-sm text-gray-400">
                        Moyenne 24h: <span id="movingAverageHum">--%</span>
                    </div>
                </div>
                
                <div class="metric-card fade-in">
                    <div class="metric-label">üî•√âtat Chauffage</div>
                    <div id="heaterState" class="metric-value">--</div>

                    <div class="text-sm text-gray-400">
                        Mode : <span id="currentMode">--</span>
                    </div>

                    <div class="text-sm text-gray-400" id="modeDetails">
                        <!-- PID ou hyst√©r√©sis -->
                    </div>

                    <div class="text-sm text-gray-400">
                        Consigne : <span id="consigneTemp">--¬∞C</span>
                    </div>
                </div>
                
                <div class="metric-card fade-in">
                    <div class="metric-label">Syst√®me</div>
                    <div class="metric-value text-lg">
                        <span class="status-indicator status-online"></span>WiFi
                    </div>
                    <div class="metric-value text-lg">
                        <span id="led-dot" class="status-indicator" style="background-color: #000;"></span>
                        <span> LED</span>
                    </div>
                    <div class="text-sm text-gray-400  mt-2" id="currentTime">--:--</div>
                </div>
            </div>

            <!-- Charts Section -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
                <div class="card">
                    <h3 class="text-xl font-semibold mb-4 flex items-center">
                        <i class="fas fa-thermometer-half text-orange-500 mr-2"></i>
                        √âvolution Temp√©rature
                    </h3>
                    <div class="chart-container">
                        <canvas id="tempChart"></canvas>
                    </div>
                </div>
                
                <div class="card">
                    <h3 class="text-xl font-semibold mb-4 flex items-center">
                        <i class="fas fa-tint text-blue-400 mr-2"></i>
                        √âvolution Humidit√©
                    </h3>
                    <div class="chart-container">
                        <canvas id="humidityChart"></canvas>
                    </div>
                </div>
            </div>

            <!-- Camera Section -->
            <div class="card mb-8" id="cameraContainer" style="display: none;">
                <h3 class="text-xl font-semibold mb-4 flex items-center">
                    <i class="fas fa-video text-purple-500 mr-2"></i>
                    Stream Cam√©ra
                </h3>
                <div class="flex justify-center">
                    <!-- 
                        <img id="camStream" class="rounded-lg border border-gray-800 max-w-full h-auto responsive-img" 
                        src="/capture" alt="Stream cam√©ra" > 
                    -->  
                        <!-- Streaming MJPEG natif -->
                        <img id="camStream" class="rounded-lg border border-gray-800 max-w-full h-auto responsive-img" 
                        src="/mjpeg" style="width: 100%; max-width: 640px;" alt="Stream cam√©ra" > 

                         
                        <!-- Ou avec un √©l√©ment vid√©o (plus compatible) --
                        <video id="camStream" autoplay muted style="width: 100%; max-width: 640px;" class="rounded-lg border border-gray-800 max-w-full h-auto responsive-img">
                            <source src="/mjpeg" type="video/x-mjpeg" style="width: 100%; max-width: 640px;" alt="Stream cam√©ra" >
                            Votre navigateur ne supporte pas MJPEG.
                        </video>
                        -->  
                </div>







            </div>

        </div>

        <!-- Configuration Tab -->
        <div id="configContent" class="tab-content" style="display: none;">
            
            <div class="grid grid-cols-1 lg:grid-cols-1 gap-8">

                <!-- Courbe d'√©dition du jour (remplace la courbe de chauffage) -->
                <div class="card">
                    <h3 class="text-xl font-semibold mb-6 flex items-center">
                        <i class="fas fa-thermometer-half text-blue-500 mr-2"></i>
                        üìä Courbe d'√©dition du jour
                    </h3>
                    
                    <!-- Navigation saisonni√®re - Affich√©e seulement si mode saisonnier activ√© -->
                    <div id="seasonalNavigation" class="mb-6" style="display: none;">
                        <div class="flex items-center justify-between bg-gray-800 p-4 rounded-lg">
                            <div id="selectedDayInfo" class="text-white">
                                <div class="font-semibold">üìÖ Mode Saisonnier Activ√©</div>
                                <div class="text-sm text-gray-400">S√©lectionnez un jour dans le calendrier ci-dessous pour l'√©diter</div>
                            </div>
                            <div id="dayNavigationControls" class="flex items-center space-x-4" style="display: none;">
                                <button id="prevDayBtn" class="btn-secondary">
                                    <i class="fas fa-chevron-left mr-2"></i>Jour Pr√©c√©dent
                                </button>
                                <button id="saveDayBtn" class="btn-success">
                                    <i class="fas fa-save mr-2"></i>Sauvegarder ce Jour
                                </button>
                                <button id="nextDayBtn" class="btn-secondary">
                                    Jour Suivant<i class="fas fa-chevron-right ml-2"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <div class="chart-container">
                        <canvas id="configTempChart"></canvas>
                    </div>

                    <!-- Vue Annuelle - D√âPLAC√âE AU-DESSUS des Profils Pr√©d√©finis -->
                    <div id="seasonalHeatmap" class="mt-8" style="display: none;">
                        <h4 class="text-lg font-semibold mb-4 flex items-center">
                            <i class="fas fa-fire text-orange-500 mr-2"></i>
                            üìÖ Vue Annuelle - Calendrier des Temp√©ratures
                        </h4>
                        
                        <div class="mb-4">
                            <div class="text-sm text-gray-400 mb-2">
                                Chaque case repr√©sente un jour de l'ann√©e. La couleur indique la temp√©rature moyenne du jour.
                                <span class="text-blue-400">Bleu = Froid</span> ‚Ä¢ 
                                <span class="text-red-400">Rouge = Chaud</span>
                            </div>
                        </div>
                        
                        <div id="heatmapCanvas" class="w-full bg-gray-900 rounded-lg p-4" style="min-height: 200px;">
                            <!-- La heatmap sera g√©n√©r√©e ici par JavaScript -->
                        </div>
                        
                        <div class="mt-4 text-center">
                            <div class="text-sm text-gray-400">
                                üñ±Ô∏è Cliquez sur un jour pour l'√©diter ‚Ä¢ üé® Les couleurs repr√©sentent les temp√©ratures moyennes
                            </div>
                        </div>
                    </div>

                    <!-- Outils de Modification - Affich√©s seulement si mode saisonnier activ√© -->
                    <div id="seasonalTools" class="mt-8" style="display: none;">
                        <h4 class="text-lg font-medium mb-4">üõ†Ô∏è Outils de Modification</h4>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                            <button id="capTempsBtn" class="btn-secondary text-sm">
                                üå°Ô∏è Plafonner les temp√©ratures d'un mois
                            </button>
                            <button id="smoothMonthBtn" class="btn-secondary text-sm">
                                üåä Lisser les courbes d'un mois
                            </button>
                            <button id="copyDayBtn" class="btn-secondary text-sm">
                                üìã Copier un jour vers un mois entier
                            </button>
                        </div>
                        
                        <div class="mt-4 p-3 bg-gray-800 rounded-lg">
                            <div class="text-sm text-gray-400">
                                üí° <strong>Astuce:</strong> Cliquez sur un jour dans le calendrier ci-dessus pour l'√©diter individuellement
                            </div>
                        </div>
                    </div>

                    <!-- Outils de Modification repositionn√©s APR√àS la Vue Annuelle -->
                    <div class="controls mt-6">
                        <div class="control-group">
                            <h3>üéõÔ∏è Profils Pr√©d√©finis</h3>
                            <div class="px-6 py-3 rounded-md duration-300">
                                <button class="btn-secondary" onclick="smoothCurve()">üåä Lisser la Courbe</button>
                                                                
                                <div class="preset-section">
                                    <div class="grid grid-cols-2 sm:grid-cols-3 gap-2 mt-4 text-sm">
                                    <button class="preset-btn" onclick="applyPreset('mer')">
                                        üêö <span class="ml-1">Bord de mer (24‚Äì29 ¬∞C)</span>
                                    </button>
                                    <button class="preset-btn" onclick="applyPreset('foret')">
                                        üçÉ <span class="ml-1">For√™t (23‚Äì28 ¬∞C)</span>
                                    </button>
                                    <button class="preset-btn" onclick="applyPreset('tropical')">
                                        üå¥ <span class="ml-1">Tropical (28‚Äì32 ¬∞C)</span>
                                    </button>
                                    <button class="preset-btn" onclick="applyPreset('desert')">
                                        ‚òÄÔ∏è <span class="ml-1">D√©sert (23‚Äì32 ¬∞C)</span>
                                    </button>
                                    <button class="preset-btn" onclick="applyPreset('constant')">
                                        ‚öñÔ∏è <span class="ml-1">Constant (25 ¬∞C)</span>
                                    </button>
                                    <button id="copieSettings" class="preset-btn" onclick="applyPreset('copie')" style="display: none;">
                                        üåç <span class="ml-1">Copie m√©t√©o locales</span>
                                    </button>
                                    <button class="preset-btn" onclick="resetToDefault()">
                                        ‚ôªÔ∏è <span class="ml-1">R√©initialiser</span>
                                    </button>
                                    </div>
                                </div>

                                <!-- === GESTION DES PROFILS SIMPLIFI√âE === -->
                                <div class="card mt-8 p-4 rounded-md shadow-md bg-gray-800 text-gray-100">
                                    <h3 class="text-xl font-semibold mb-4">üìÅ Gestion des Profils</h3>
                                    
                                    <!-- Boutons principaux -->
                                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                                        <button class="btn-success" onclick="saveProfile()">
                                            üíæ Sauvegarder Profil
                                        </button>
                                        <button class="btn-warning" onclick="refreshProfileList()">
                                            üîÑ Actualiser la liste
                                        </button>
                                    </div>
                                    
                                    <!-- Liste des profils -->
                                    <ul id="profileList" class="space-y-2 text-sm bg-gray-900 p-3 rounded border border-gray-700 max-h-60 overflow-y-auto">
                                        <li>Chargement...</li>
                                    </ul>

                                    <!-- Importation -->
                                    <div class="mt-4">
                                        <label for="profileUpload" class="block text-sm font-medium text-gray-300 mb-1">üì§ Importer un profil (.json)</label>
                                        <input type="file" id="profileUpload" accept=".json"
                                        class="block w-full text-sm text-gray-200 bg-gray-700 border border-gray-600 rounded px-2 py-1 focus:outline-none focus:ring focus:border-blue-400" />
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Weather & Location avec switch saisonnier -->
                <div class="card">
                    <h3 class="text-xl font-semibold mb-6 flex items-center">
                        <i class="fas fa-globe text-blue-500 mr-2"></i>
                        Copie des temp√©ratures d'un lieu
                    </h3>
                    
                    <div class="mb-6">
                        <label class="flex items-center justify-between">
                            <span>Mode Copie</span>
                            <label class="toggle-switch">
                                <input type="checkbox" id="weatherMode">
                                <span class="slider"></span>
                            </label>
                        </label>
                    </div>

                    <!-- Switch pour le suivi saisonnier -->
                    <div class="mb-6">
                        <label class="flex items-center justify-between">
                            <span>Activer le Suivi Saisonnier</span>
                            <label class="toggle-switch">
                                <input type="checkbox" id="seasonalMode">
                                <span class="slider"></span>
                            </label>
                        </label>
                        <div class="text-sm text-gray-400 mt-2">
                            Quand activ√©, le syst√®me utilise automatiquement les donn√©es climatiques historiques au lieu de la courbe manuelle
                        </div>
                    </div>

                    <div id="weatherSettings" style="display: none;">
                        <h3>üåç Configuration du lieu</h3>
                        
                        <!-- Coordonn√©es existantes -->
                        <div class="input-group">
                            <label class="block text-sm font-medium mb-2">Latitude</label>
                            <input type="number" id="latInput" class="input-field" step="0.0001" placeholder="48.8566">
                            <label class="block text-sm font-medium mb-2">Longitude</label>
                            <input type="number" id="lonInput" class="input-field" step="0.0001" placeholder="2.3522">
                        </div>
                        
                        <!-- Boutons de g√©olocalisation -->
                        <div class="map-controls">
                            <button type="button" onclick="getCurrentLocation()" class="btn-secondary">
                                üìç Ma Position
                            </button>
                            <button type="button" onclick="searchLocation()" class="btn-secondary">
                                üîç Rechercher
                            </button>
                            <button type="button" onclick="toggleMap()" class="btn-secondary" id="mapToggleBtn">
                                üó∫Ô∏è Ouvrir la Carte
                            </button>
                        </div>
                            
                        <!-- Conteneur de la carte -->
                        <div id="mapContainer" style="display: none; margin-top: 15px;">
                            <div id="map" style="height: 400px; width: 100%; border-radius: 8px; border: 2px solid #311616;"></div>
                            <p style="color: #ccc; font-size: 12px; margin-top: 5px;">
                                üñ±Ô∏è Cliquez sur la carte pour s√©lectionner une position
                            </p>
                        </div>

                        <!-- Bouton d'initialisation des donn√©es saisonni√®res -->
                        <div class="mt-6">
                            <button id="initSeasonalBtn" class="btn-primary w-full">
                                üì• Initialiser les donn√©es saisonni√®res
                            </button>
                            
                            <!-- Progress Bar -->
                            <div id="seasonalProgress" class="mt-4" style="display: none;">
                                <div class="text-sm text-gray-400 mb-2">Progression:</div>
                                <div class="w-full bg-gray-700 rounded-full h-2">
                                    <div id="seasonalProgressBar" class="bg-blue-600 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
                                </div>
                                <div id="seasonalProgressText" class="text-xs text-gray-400 mt-1">Initialisation...</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                <!-- Heating Control -->
                <div class="card">
                    <h3 class="text-xl font-semibold mb-6 flex items-center">
                        <i class="fas fa-fire text-red-500 mr-2"></i>
                        Contr√¥le Chauffage
                    </h3>
                    
                    <div class="mb-6">
                        <label class="flex items-center justify-between">
                            <span>Mode PWM (PID)</span>
                            <label class="toggle-switch">
                                <input type="checkbox" id="usePWM">
                                <span class="slider"></span>
                            </label>
                        </label>
                    </div>
                    
                    <div id="pwmSettings" style="display: none;">
                        <h4 class="text-lg font-medium mb-4">Param√®tres PID</h4>
                        <div class="grid grid-cols-3 gap-4 mb-4">
                            <div>
                                <label class="block text-sm font-medium mb-2">Kp</label>
                                <input type="number" id="KpSet" class="input-field" step="0.1" value="2.0">
                            </div>
                            <div>
                                <label class="block text-sm font-medium mb-2">Ki</label>
                                <input type="number" id="KiSet" class="input-field" step="0.1" value="0.5">
                            </div>
                            <div>
                                <label class="block text-sm font-medium mb-2">Kd</label>
                                <input type="number" id="KdSet" class="input-field" step="0.1" value="1.0">
                            </div>
                        </div>
                    </div>
                    
                    <div id="hysteresisSettings">
                        <div>
                            <label class="block text-sm font-medium mb-2">Hyst√©r√©sis (¬∞C)</label>
                            <input type="number" id="hysteresisSet" class="input-field" min="0.1" max="2" step="0.1" value="0.2">
                        </div>
                    </div>
                     
                    <div class="mb-6 mt-8">
                        <label class="flex items-center justify-between">
                            <span>Limiter la temp√©rature</span>
                            <label class="toggle-switch">
                                <input type="checkbox" id="useLimitTemp">
                                <span class="slider"></span>
                            </label>
                        </label>
                    </div>
                    
                    <div id="limitTempSettings" style="display: none;">
                        <div class="grid grid-cols-2 gap-4 mb-4">
                            <div>
                                <label class="block text-sm font-medium mb-2">Minimum</label>
                                <input type="number" id="minTempSet" class="input-field" step="0.1" value="0">
                            </div>
                            <div>
                                <label class="block text-sm font-medium mb-2">Maximum</label>
                                <input type="number" id="maxTempSet" class="input-field" step="0.1" value="40">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Camera Configuration -->
                <div class="card">
                    <h3 class="text-xl font-semibold mb-6 flex items-center">
                        <i class="fas fa-camera text-purple-500 mr-2"></i>
                        Configuration Cam√©ra
                    </h3>
                    
                    <div class="mb-6">
                        <label class="flex items-center justify-between">
                            <span>Activer Cam√©ra</span>
                            <label class="toggle-switch">
                                <input type="checkbox" id="showCamera">
                                <span class="slider"></span>
                            </label>
                        </label>
                    </div>
                    
                    <div class="mb-4">
                        <label class="block text-sm font-medium mb-2">Qualit√© Stream</label>
                        <select id="cameraResolution" class="input-field">
                            <option value="qvga">QVGA (320x240)</option>
                            <option value="vga">VGA (640x480)</option>
                            <option value="svga">SVGA (800x600)</option>
                        </select>
                    </div>

                    <div class="mb-6">
                        <label class="flex items-center justify-between">
                            <span>Mode Debug</span>
                            <label class="toggle-switch">
                                <input type="checkbox" id="debugMode">
                                <span class="slider"></span>
                            </label>
                        </label>
                    </div>
                </div>
            </div>

            <!-- LED Control - Section s√©par√©e -->
            <div class="card">
                <h3 class="text-xl font-semibold mb-6 flex items-center">
                    <i class="fas fa-lightbulb text-yellow-400 mr-2"></i>
                    Contr√¥le LED
                </h3>

                <div class="mb-6">
                    <label class="flex items-center justify-between">
                        <span>Allumer / √âteindre</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="led-toggle">
                            <span class="slider"></span>
                        </label>
                    </label>
                </div>

                <div class="mb-4">
                    <label class="block text-sm font-medium mb-2">Intensit√©</label>
                    <div class="flex items-center">
                        <input type="range" id="brightness-slider" min="0" max="255" value="255" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                        <span id="brightness-value" class="ml-4 text-lg font-semibold">255</span>
                    </div>
                </div>

                <div class="mb-4">
                    <label class="block text-sm font-medium mb-2">Couleur</label>
                    <input type="color" id="color-picker" value="#ffffff" class="input-field w-full h-10 p-1">
                </div>
            </div>

            <!-- Save Configuration -->
            <div class="card">
                <h3 class="text-xl font-semibold mb-6 flex items-center">
                    <i class="fas fa-save text-green-500 mr-2"></i>
                    Sauvegarde
                </h3>
                
                <button id="applyBtn" class="btn-primary w-full" onclick="applyAllSettings()">
                    <i class="fas fa-download mr-2"></i>
                    Sauvegarder Configuration
                </button>
            </div>
        </div>
    </div>
    
    <!-- Scripts -->
	<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/spectrum/1.8.0/spectrum.min.js"></script>  
    <script src="/js/api.js"></script>
    <script src="/js/surveillance.js"></script>
    <script src="/js/configuration.js"></script>
    <script src="/js/seasonal.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/map.js"></script>

</body>
</html>